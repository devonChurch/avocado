{"version":3,"sources":["LoadControl.js","utils.js","Swatch.js","Composition.js","Header.js","Scroll.js","App.js","index.js"],"names":["LoadControl","callback","throttleId","debounceId","createThrottle","action","window","requestAnimationFrame","removeThrottle","cancelAnimationFrame","checkIsThrottling","Boolean","createDebounce","args","setTimeout","removeDebounce","clearTimeout","useLoadControl","loadControl","useRef","useEffect","createLoadControl","cleanUpLoadControl","current","createSwatch","hex","tinyColor","FOCUS_SHADOW_500","setAlpha","LUMINANCE_SHADOW_500","findColorComplementFromSwatches","compareId","swatches","compareHex","get","hexes","values","complementHex","mostReadable","toHexString","entries","find","checkHasLowLuminance","getLuminance","updateLuminanceStatic","lighten","darken","isLuminant","luminance","createColorCompanion","createUpdate","alpha","prevSwatch","toHsl","luminanceBefore","l","nextSwatch","toString","createOffsetColor","createFocusColor","createActiveColor","createFocusborder","createFocusStateWithShadow","resetList","css","positionAbsolute","defaultSwatches","Map","defaultCompositions","baseId","contentId","deleteAnimation","offset","keyframes","deleteKeyframes","SwatchList","styled","ul","UserItem","div","isUserDragging","isDragged","isAboutToDrag","shouldSwatchRegress","isDeleting","styles","createFocusState","swatchActiveState","DragHitBox","shouldSwatchPronounce","hasCapacityToDelete","ReorderTransformation","reorderTransform","AddItem","li","AddButton","button","isTargeted","createTargetColor","Input","input","DeleteButton","Swatches","UserSwatch","memo","swatchId","handleChange","handleDragStart","handleDragOver","handleDragExit","handleDragEnd","handleDrop","handleDelete","createReorderTransform","useState","setIsDragged","setIsAboutToDrag","swatchRef","inputValue","setInputValue","handleLoadControledChange","value","draggable","ref","onDragStart","event","dataTransfer","setData","setDragImage","SWATCH_WIDTH","onDragEnd","onDragOver","preventDefault","onDragLeave","onDrop","onPointerDown","undefined","onPointerUp","onClick","querySelector","focus","CSSTransition","unmountOnExit","in","timeout","classNames","icon","faTimes","size","type","onChange","target","AppendSwatch","dragHex","handleClick","setIsTargeted","onPointerEnter","onPointerLeave","faPlus","CompList","SPACE_500","IconList","DividerList","ResultList","Character","span","children","Examples","baseHex","contentHex","SmallText","isBold","Divider","height","Compositions","findAccessibilityLevel","comparison","level","isReadable","createAccessibilityComparison","Icons","faCheckCircle","faCalendarAlt","faCommentDots","faStar","faTrashAlt","map","index","key","Dividers","Level","characters","split","char","DropAreas","ResultIcon","FontAwesomeIcon","Results","includes","faCheck","percentage","readability","Math","round","createContrastPercentage","ItemWrapper","AddCompositionButton","isActive","AddSlotButton","UserComposition","compId","dragStartId","setActiveCompositionId","removeActiveCompositionId","isContentTargeted","setIsContentTargeted","isBaseTargeted","setIsBaseTargeted","AppendComposition","isAddTargeted","setIsAddTargeted","Button","ButtonHeader","header","Header","handleDeleteToggle","as","href","faGithubAlt","faTasks","Scroll","setScroll","innerHeight","nextScroll","scrollY","isTooHigh","isTooLow","document","body","clientHeight","scroll","viewPortQuarter","pointerPosition","clientY","isOverTopQuarter","isOverBottomQuarter","maxScrollOffset","isThrottling","shouldStopScroll","createDragLoadControl","cleanUpDragLoadControl","dragLoadControl","addEventListener","removeEventListener","GlobalStyle","createGlobalStyle","createSwatchKey","nanoid","createCompositionKey","createIndexComparison","idOne","idTwo","findSwatchIndexFromId","id","findIndex","findCompositionIndexFromId","compositions","x","y","calculateReorderTransform","dragOverId","swatchIndex","dragStartIndex","dragOverIndex","prevNode","nextNode","prevY","offsetTop","prevX","offsetLeft","nextY","nextX","App","setSwatches","setLoadControledSwatches","setDragStartId","setDragOverId","removeDragOverId","useCallback","removeDragIds","appendSwatch","updateUserSwatch","moveSwatchToNewLocation","dropId","prevSwatches","shoudPrepend","dropSwatch","nextSwatches","reduce","acc","createReorderTransformHandler","setCompositions","activeCompositionId","appendComposition","compositionIds","updateComposition","composition","prevComps","compIndex","nextComps","slice","search","qs","parse","ignoreQueryPrefix","s","c","swatchMap","compMap","hasUserConfig","convertStateFromQuery","location","swatchFlat","swatchKeys","keys","compFlat","indexOf","stringify","addQueryPrefix","convertStateToQuery","protocol","host","pathname","url","history","replaceState","setIsDeleting","deleteSwatch","deleteComposition","hasEnoughSwatchesToDelete","hasEnoughCompositionsToDelete","checkIsSwatchInAnyComposition","activeSwatchIds","TransitionGroup","component","hasBase","hasContent","setSwatchAppearanceAgainstCompositionTarget","pop","lastHex","ReactDOM","render","getElementById"],"mappings":"0QAEaA,EAAc,SAACC,GAE1B,IAAIC,EAOAC,EANEC,EAAiB,SAACC,GAAD,OAAaH,EAAaI,OAAOC,sBAAsBF,IACxEG,EAAiB,kBAAON,EAAaI,OAAOG,qBAAqBP,IACjEQ,EAAoB,kBAAMC,QAAQT,IAKlCU,EAAiB,sCAAIC,EAAJ,yBAAIA,EAAJ,uBACpBV,EAAaG,OAAOQ,YAAW,kBAAMb,EAAQ,WAAR,EAAYY,KAHtB,MAIxBE,EAAiB,kBAAMT,OAAOU,aAAab,IAsCjD,MAAO,CAlCmB,kBAAM,WAAc,IAAD,uBAATU,EAAS,yBAATA,EAAS,gBACvCH,KAWFK,IACAH,EAAc,WAAd,EAAkBC,IASlBT,GAAe,WACbH,EAAQ,WAAR,EAAYY,GACZL,SAKqB,WACzBA,IACAO,OAMSE,EAAiB,SAAChB,GAC7B,IAAMiB,EAAcC,mBAWpB,OATAC,qBAAU,WAAO,IAAD,EACkCpB,EAAYC,GAD9C,mBACPoB,EADO,KACYC,EADZ,KAGd,OADAJ,EAAYK,QAAUF,IACfC,IACN,IAKIJ,EAAYK,SAAWtB,G,0tCC/DzB,IAAMuB,EAAe,SAAAC,GAAG,OAAIC,IAAUD,IAuChCE,EAAgB,mBA5BF,EA4BE,cAAgCH,EAnBxC,QAmB4DI,SAAS,MAE7EC,EAAoB,sBA/BL,EA+BK,cAAoCL,EArBhD,QAqBoEI,SACvF,KAGWE,EAAkC,SAACC,EAAWC,GACzD,IAAMC,EAAaD,EAASE,IAAIH,GAC1BI,EAAK,YAAOH,EAASI,UACrBC,EAAgBX,IAAUY,aAAaL,EAAYE,GAAOI,cAHM,EAI/C,YAAIP,EAASQ,WAAWC,MAAK,yCAAqBJ,KAEzE,OANsE,qBAS3DK,EAAuB,SAAAjB,GAAG,OAAID,EAAaC,GAAKkB,eAAiB,IAExEC,EAAwB,SAACC,EAASC,GAAV,OAAqB,SAACC,EAAYC,GAAb,OACjDD,EAAaF,EAAUC,IAOnBG,EAAuB,SAACC,GAAD,IAAeC,EAAf,uDAAuB,EAAvB,OAA6B,SAAA1B,GACxD,IAAM2B,EAAa5B,EAAaC,GAAK4B,QAC1BC,EAAoBF,EAAvBG,EAGFC,EAAU,KAAQJ,EAAR,CAAoBG,EADbL,EADJI,EAAkB,GACWA,KAGhD,OAAO5B,IAAU8B,GACd5B,SAASuB,GACTM,aAGQC,EAAoBT,EAAqBL,EAAsB,GAAK,KAEpEe,EAAmBV,EAAqBL,EAAsB,GAAK,IAAM,IACzEgB,EAAoBX,EAAqBL,EAAsB,GAAK,IAAM,GAE1EiB,EAAoB,SAAApC,GAAG,sBAtET,EAsES,cAA8BkC,EAAiBlC,KAEtEqC,EAA6B,SAAArC,GAAG,gBAAOE,EAAP,aAA4BkC,EAAkBpC,KAE9EsC,EAAYC,YAAH,KAMTC,EAAmBD,YAAH,KAQvBE,EAAkB,IAAIC,IAAI,CAC9B,CAAC,IAAK3C,EAAa,qBAAqBe,eACxC,CAAC,IAAKf,EAAa,sBAAsBe,eACzC,CAAC,IAAKf,EAAa,sBAAsBe,eACzC,CAAC,IAAKf,EAAa,oBAAoBe,eACvC,CAAC,IAAKf,EAAa,mBAAmBe,iBAGlC6B,EAAsB,IAAID,IAAI,CAClC,CAAC,IAAK,CAAEE,OAAQ,IAAKC,UAAW,MAChC,CAAC,IAAK,CAAED,OAAQ,IAAKC,UAAW,MAChC,CAAC,IAAK,CAAED,OAAQ,IAAKC,UAAW,QAsCrBC,EAAkB,SAAAC,GAAM,OAAIR,YAAJ,IAVN,SAAAQ,GAAM,OAAIC,YAAJ,IAEZD,EAIDA,GAMeE,CAAgBF,K,o3JCnHvD,IAAMG,GAAaC,IAAOC,GAAV,KACZd,ED3BwB,aCwCtBe,GAAWF,IAAOG,IAAV,KACVd,GACY,qBAAGxC,MDtBM,IADA,IACA,SC2BrB,YAAyF,IAAtFA,EAAqF,EAArFA,IAAKuD,EAAgF,EAAhFA,eAAgBC,EAAgE,EAAhEA,UAAWC,EAAqD,EAArDA,cAAeC,EAAsC,EAAtCA,oBAAqBC,EAAiB,EAAjBA,WACnEC,EAAS,GA4Eb,OAlEI3C,EAAqBjB,KACvB4D,GAAM,yCAEApB,EAFA,kEAIYpC,EAJZ,+FDxCa,ICwCb,4BAYJoD,GAAaD,GAAkBE,GAAiBC,GAAuBC,KACzEC,GAAM,mCDhEiB,ECgEjB,iBAKJL,GAAkBI,KACpBC,GAAM,qCDvDa,GCuDb,eAeJJ,GAAaD,IACfK,GAAM,gCDpFS,OCoFT,cAsBJH,IACFG,GAAM,iCACU,mBD7CU,SAAA5D,GAAG,OAAIoC,EAAkBpC,GC6CtB6D,CAAb,EAAG7D,OADb,qFD7Fa,GC6Fb,eAODuC,YAAP,KACIqB,MAKFE,GAAoBvB,YAAH,KAGnBc,IACc,gBAAGrD,EAAH,EAAGA,IAAH,OAAaqC,EAA2BrC,KD9H7B,GCwIvB+D,GAAaZ,IAAOG,IAAV,KD7HS,KCuIZ,qBAAGE,UAA6B,IAAM,OAE/C,gBAAGD,EAAH,EAAGA,eAAgBI,EAAnB,EAAmBA,WAAnB,OACCJ,IACAI,GAMDpB,YAPA,KAUMuB,OAIN,qBAAGJ,qBAEHnB,YADmB,KDrJE,OC2JrB,qBAAGyB,uBAAqDF,MAExD,gBAAGH,EAAH,EAAGA,WAAYM,EAAf,EAAeA,oBAAf,OACAN,GAAcM,GAAuBnB,EAAgB,KD5JhC,GC8KnBoB,GAAwBf,IAAOG,IAAV,KACvBd,EDrLqB,KCwLrB,gBAAG2B,EAAH,EAAGA,iBAAH,OACA5B,YADC,KAEG4B,MAGJ,YAWA,OAXwB,EAArBZ,gBAYD,KAAK,EACH,OAAOhB,YAAP,MAGF,QACE,OAAOA,YAAP,SAOK6B,GAAUjB,IAAOkB,GAAV,ID9OK,EAyBA,IAIA,GAEA,GCqOZC,GAAYnB,IAAOoB,OAAV,ID7PM,GCgQQ,gBAAGvE,EAAH,EAAGA,IAAH,OAAaiC,EAAkBjC,KDzPtC,GC2PlB,gBAAGA,EAAH,EAAGA,IAAH,OAAaiC,EAAkBjC,KDhPjB,KC8PrB,qBAAGwE,WAECjC,YADM,KAEU,mBDhNS,SAAAvC,GAAG,OAAIA,ECgNHyE,CAAb,EAAGzE,OD1PF,IAjCA,IACA,KCgSjBuC,YARM,KASU,qBAAGvC,MDpQF,OC0QP,gBAAGA,EAAH,EAAGA,IAAH,OAAaqC,EAA2BrC,MAIxC,gBAAGA,EAAH,EAAGA,IAAH,OAAamC,EAAkBnC,MAI3C0E,GAAQvB,IAAOwB,MAAV,IACPnC,GAKSoC,GAAezB,YAAOmB,GAAPnB,CAAH,IDlTA,SAFA,MA4BA,GA5BA,MA8BA,GCgTZ0B,GAAW3B,GAEX4B,GAAaC,gBACxB,YAgBO,IAfLC,EAeI,EAfJA,SACAhF,EAcI,EAdJA,IACAiF,EAaI,EAbJA,aACAC,EAYI,EAZJA,gBACAC,EAWI,EAXJA,eACAC,EAUI,EAVJA,eACAC,EASI,EATJA,cACAC,EAQI,EARJA,WACA/B,EAOI,EAPJA,eACAI,EAMI,EANJA,WACA4B,EAKI,EALJA,aACAtB,EAII,EAJJA,oBACAuB,EAGI,EAHJA,uBACAxB,EAEI,EAFJA,sBACAN,EACI,EADJA,oBACI,EAC8B+B,oBAAS,GADvC,mBACGjC,EADH,KACckC,EADd,OAEsCD,oBAAS,GAF/C,mBAEGhC,EAFH,KAEkBkC,EAFlB,KAGEC,EAAYlG,iBAAO,MAHrB,EAgBgC+F,mBAASzF,GAhBzC,mBAgBG6F,EAhBH,KAgBeC,EAhBf,KAiBEC,EAA4BvG,GAAe,SAACwG,GAAD,OAAWf,EAAaD,EAAUgB,MAEnF,OACE,kBAACjC,GAAD,cACM,CACFP,YACAD,iBACAvD,MACAgE,wBACAN,sBACAC,aACAM,uBARJ,CAUEgC,WAAYtC,EACZuC,IAAKN,EACLO,YAAa,SAACC,GACZT,GAAiB,GAKjBS,EAAMC,aAAaC,QAAQ,aAAc,UAOzCF,EAAMC,aAAaE,aAAaX,EAAU9F,QAD3B0G,OAGfd,GAAa,GACbR,EAAgBF,IAElByB,UAAW,WACTf,GAAa,GACbL,KAEFqB,WAAY,SAACN,GACXjB,EAAeH,GAKfoB,EAAMO,kBAERC,YAAaxB,EACbyB,OAAQ,SAACT,GACPV,GAAa,GACbJ,EAAWN,GAKXoB,EAAMO,kBAERG,cAAenD,OAAaoD,EAAY,kBAAMpB,GAAiB,IAC/DqB,YAAarD,OAAaoD,EAAY,kBAAMpB,GAAiB,IAC7DsB,QAAS,WAOP,IAAMtC,EAAQiB,EAAU9F,QAAQoH,cAAc,SAC9CvC,GAASA,EAAMwC,WAGjB,kBAACjD,GAAD,cACM,CAAEV,YAAWD,kBADnB,CAEEY,iBAAkBqB,EAAuBI,EAAU9F,WAEnD,kBAACuD,GACK,CACFrD,MACAwD,YACAD,iBACAE,gBACAC,sBACAC,cAGF,kBAACyD,EAAA,EAAD,CACEC,eAAa,EACbC,GAAI3D,GAAcM,EAClBsD,QD9aW,IC+aXC,WAAW,cAEX,kBAAC5C,GAAD,CAAc5E,IDvbJ,UCubmBiH,QAAS,kBAAM1B,EAAaP,KACvD,kBAAC,IAAD,CAAiByC,KAAMC,IAASC,KAAK,WAIzChE,GACA,kBAACe,GAAD,CACEkD,KAAK,QACL5B,MAAOH,EACPgC,SAAU,SAACzB,GAAW,IACZJ,EAAUI,EAAM0B,OAAhB9B,MACRF,EAAcE,GACdD,EAA0BC,WAU7B+B,GAAehD,gBAAK,YAA2C,IAAxCiD,EAAuC,EAAvCA,QAASC,EAA8B,EAA9BA,YAAa3C,EAAiB,EAAjBA,WAAiB,EACrCG,oBAAS,GAD4B,mBAClEjB,EADkE,KACtD0D,EADsD,KAGzE,OACE,kBAAC9D,GAAD,KACE,kBAACE,GAAD,cACM,CAAEE,cADR,CAEExE,IAAKwE,GAAcwD,EAAUA,EDpdb,UCqdhBf,QAASgB,EACTvB,WAAY,SAACN,GAKX8B,GAAc,GACd9B,EAAMO,kBAERC,YAAa,kBAAMsB,GAAc,IACjCC,eAAgB,kBAAMD,GAAc,IACpCE,eAAgB,kBAAMF,GAAc,IACpCrB,OAAQ,SAACT,GACPd,IACA4C,GAAc,GAKd9B,EAAMO,oBAGR,kBAAC,IAAD,CAAiBc,KAAMY,IAAQV,KAAK,Y,mxKC3d5C,IAAMW,GAAWnF,IAAOC,GAAV,KACVd,EFpCqB,GAQOiG,IACCA,IAwBL,IAhCH,GAUQA,IAHDA,IAyBJ,IAxBKA,IADDA,KEiD1BC,GAAWrF,IAAOC,GAAV,KACVd,EF1DqB,GAiCG,IAhCH,IEoEnBmG,GAActF,IAAOC,GAAV,KACbd,EFtEqB,GAiCG,IAhCH,IE+EnBoG,GAAavF,IAAOC,GAAV,KACZd,EFpEyB,IAML,UAGA,UAtBC,GAiCG,IAhCH,IEqGnBqG,GAAYxF,IAAOyF,KAAV,MACF,kBAAgC,MAAhC,EAAGC,SAAmC,EAAI,OAGjDxF,GAAWF,IAAOG,IAAV,KFlFW,KE0FrB,qBAAGC,gBAEHhB,YADc,KFvFO,OE8FrB,gBAAGoB,EAAH,EAAGA,WAAYM,EAAf,EAAeA,oBAAf,OACAN,GAAcM,GAAuBnB,EAAgB,OAGnDgG,GAAW3F,IAAOG,IAAV,MAQC,qBAAGyF,WACA,qBAAGC,aF1HQ,IAbJ,MAyBA,IAQG,IAhCH,OE6JrB,YAAkB,IAAfD,EAAc,EAAdA,QAKH,GAAI9H,EAAqB8H,GACvB,OAAOxG,YAAP,KAEMC,EFzJiB,IE2JLpC,MASlB6I,GAAY9F,IAAOyF,KAAV,MAOA,gBAAGM,EAAH,EAAGA,OAAH,gBAAmBA,EAAS,GAAK,GAAjC,SACE,qBAAGA,OAAuB,OAAS,aAG9CC,GAAUhG,IAAOG,IAAV,KF/KgB,GEiLjB,gBAAG8F,EAAH,EAAGA,OAAH,gBAAmBA,EAAnB,SAICC,GAAef,GAYtBgB,GAAyB,SAACP,EAASC,GACvC,IAAMO,EAJ8B,SAACR,EAASC,GAAV,OAAyB,SAAAQ,GAAK,OAClEvJ,IAAUwJ,WAAWV,EAASC,EAAY,CAAEQ,QAAO7B,KAAM,WAGtC+B,CAA8BX,EAASC,GAE1D,QAAQ,GACN,KAAKO,EAAW,OACd,MAAO,MACT,KAAKA,EAAW,MACd,MAAO,MACT,QACE,MAAO,QAIPI,GAAQ,kBACZ,6BACE,kBAACnB,GAAD,KACG,CAACoB,KAAeC,KAAeC,KAAeC,KAAQC,MAAYC,KAAI,SAACxC,EAAMyC,GAAP,OACrE,wBAAIC,IAAKD,GACP,kBAAC,IAAoB,CAAEzC,gBAO3B2C,GAAW,kBACf,6BACE,kBAAC3B,GAAD,KACG,CAAC,EAAG,EAAG,GAAGwB,KAAI,SAAAb,GAAM,OACnB,wBAAIe,IAAKf,GACP,kBAACD,GAAY,CAAEC,kBAOnBiB,GAAQ,SAAC,GAAyB,IAChCC,EAD+B,EAAtBzB,SAEZ0B,MAAM,IACNN,KAAI,SAACO,EAAMN,GAAP,OAAiB,kBAACvB,GAAD,CAAWwB,IAAKD,GAAQM,MAEhD,OAAO,8BAAOF,IAGVG,GAAYtH,IAAOG,IAAV,KACXd,EF5PqB,GACA,GAuBA,KE6OrB,qBAAGe,gBAEHhB,YADA,KFvOqB,OAEG,IAhCH,IEiRnBmI,GAAavH,YAAOwH,IAAPxH,CAAH,KFnPS,KEuPnByH,GAAU,SAAC,GAA6B,IAA3B7B,EAA0B,EAA1BA,QAASC,EAAiB,EAAjBA,WACpBQ,EAAQF,GAAuBP,EAASC,GACxCvB,EAAO+B,EAAMqB,SAAS,MAAQC,IAAUpD,IACxCqD,EArFyB,SAAChC,EAASC,GACzC,IACM+B,EADQ9K,IAAU+K,YAAYjC,EAASC,GACjB,GAAM,IAElC,OAAOiC,KAAKC,MAAMH,GAiFCI,CAAyBpC,EAASC,GAErD,OACE,6BACE,kBAACN,GAAD,KACE,kBAACgC,GAAD,cAAgB,CAAEjD,QAAlB,CAA0BE,KAAK,QAC/B,kBAAC,GAAD,KAAQ6B,GACR,8BAAOuB,EAAP,QAMFK,GAAcjI,IAAOkB,GAAV,KF9QQ,IAGA,GAGA,GE6RnBgH,GAAuBlI,YAAOmB,GAAPnB,CAAH,MACtB,qBAAGmI,SAEC/I,YADI,MAIJA,YAJI,SAUNgJ,GAAgBpI,YAAOmB,GAAPnB,CAAH,KFtSS,KEmTfqI,GAAkBzG,gBAC7B,YAeO,IAdL0G,EAcI,EAdJA,OACA7I,EAaI,EAbJA,OACAC,EAYI,EAZJA,UACA6I,EAWI,EAXJA,YACA3C,EAUI,EAVJA,QACAC,EASI,EATJA,WACAhB,EAQI,EARJA,QACAzE,EAOI,EAPJA,eACAI,EAMI,EANJA,WACAM,EAKI,EALJA,oBACAsB,EAII,EAJJA,aACAD,EAGI,EAHJA,WACAqG,EAEI,EAFJA,uBACAC,EACI,EADJA,0BACI,EAC8CnG,oBAAS,GADvD,mBACGoG,EADH,KACsBC,EADtB,OAEwCrG,oBAAS,GAFjD,mBAEGsG,EAFH,KAEmBC,EAFnB,KAIJ,OACE,kBAACZ,GAAD,KACE,kBAAC,GAAD,cACM,CAAE7H,iBAAgBI,aAAYM,uBADpC,CAEEkE,eAAgBxE,OAAaoD,EAAY,kBAAM4E,EAAuBF,IACtErD,eAAgBzE,OAAaoD,EAAY6E,IAEzC,kBAAC9C,GAAa,CAAEC,UAASC,cACvB,kBAACC,GAAD,6BACA,kBAACA,GAAD,CAAWC,QAAM,GAAjB,4BACA,kBAAC,GAAD,MACA,kBAAC,GAAD,OAEF,kBAAC,GAAY,CAAEH,UAASC,eACxB,kBAAC5B,EAAA,EAAD,CACEC,eAAa,EACbC,GAAI3D,GAAcM,EAClBsD,QFhWa,IEiWbC,WAAW,cAEX,kBAAC5C,GAAD,CAAc5E,IFzWF,UEyWiBiH,QAAS,kBAAM1B,EAAakG,KACvD,kBAAC,IAAD,CAAiBhE,KAAMC,IAASC,KAAK,UAI3C,kBAAC8C,GAAc,CAAElH,kBACf,kBAACgI,GAAD,CACEvL,IAAK6L,EAAoB7D,EAAUgB,EACnCxE,WAAYqH,EACZnF,WAAY,SAAAN,GACV0F,GAAqB,GACrB1F,EAAMO,kBAERC,YAAa,kBAAMkF,GAAqB,IACxCjF,OAAQ,SAAAT,GACNd,EAAWmG,EAAQ,CAAE5I,UAAW6I,EAAa9I,WAC7CkJ,GAAqB,GACrBE,GAAkB,GAClB5F,EAAMO,mBAGR,kBAAC,IAAD,CAAiBc,KAAMY,IAAQV,KAAK,QAEtC,kBAAC4D,GAAD,CACEvL,IAAK+L,EAAiB/D,EAAUe,EAChCvE,WAAYuH,EACZrF,WAAY,SAAAN,GACV4F,GAAkB,GAClB5F,EAAMO,kBAERC,YAAa,kBAAMoF,GAAkB,IACrCnF,OAAQ,SAAAT,GACNd,EAAWmG,EAAQ,CAAE5I,YAAWD,OAAQ8I,IACxCI,GAAqB,GACrBE,GAAkB,GAClB5F,EAAMO,mBAGR,kBAAC,IAAD,CAAiBc,KAAMY,IAAQV,KAAK,aAQnCsE,GAAoBlH,gBAC/B,YAAwE,IAArEiD,EAAoE,EAApEA,QAAS0D,EAA2D,EAA3DA,YAAazD,EAA8C,EAA9CA,YAAa3C,EAAiC,EAAjCA,WAAY/B,EAAqB,EAArBA,eAAqB,EAC3BkC,oBAAS,GADkB,mBAC9DyG,EAD8D,KAC/CC,EAD+C,OAEnB1G,oBAAS,GAFU,mBAE9DoG,EAF8D,KAE3CC,EAF2C,OAGzBrG,oBAAS,GAHgB,mBAG9DsG,EAH8D,KAG9CC,EAH8C,KAKrE,OACE,kBAAC5H,GAAD,KACE,kBAACqG,GAAc,CAAElH,kBACf,kBAACgI,GAAD,CACEvL,IAAK6L,EAAoB7D,EFjab,UEkaZxD,WAAYqH,EACZnF,WAAY,SAAAN,GACV0F,GAAqB,GACrB1F,EAAMO,kBAERC,YAAa,kBAAMkF,GAAqB,IACxCjF,OAAQ,SAAAT,GACNd,EAAW,CAAEzC,UAAW6I,IACxBI,GAAqB,GACrB1F,EAAMO,mBAGR,kBAAC,IAAD,CAAiBc,KAAMY,IAAQV,KAAK,QAEtC,kBAAC4D,GAAD,CACEvL,IAAK+L,EAAiB/D,EFjbV,UEkbZxD,WAAYuH,EACZrF,WAAY,SAAAN,GACV4F,GAAkB,GAClB5F,EAAMO,kBAERC,YAAa,kBAAMoF,GAAkB,IACrCnF,OAAQ,SAAAT,GACNd,EAAW,CAAE1C,OAAQ8I,IACrBI,GAAqB,GACrBE,GAAkB,GAClB5F,EAAMO,mBAGR,kBAAC,IAAD,CAAiBc,KAAMY,IAAQV,KAAK,SAGxC,kBAAC0D,GAAD,CACErL,IFncc,UEocdsL,UAAW/H,EACXiB,WAAY0H,EACZjF,QAASgB,EACTE,eAAgB,kBAAMgE,GAAiB,IACvC/D,eAAgB,kBAAM+D,GAAiB,KAEvC,kBAAC,IAAD,CAAiB1E,KAAMY,IAAQV,KAAK,Y,6YCtc9C,IAAMyE,GAASjJ,YAAOmB,GAAPnB,CAAH,KHvBa,GADA,GGoCnBkJ,GAAelJ,IAAOmJ,OAAV,KHhCO,IGsCZC,GAASxH,gBAAK,gBAAGpB,EAAH,EAAGA,WAAY6I,EAAf,EAAeA,mBAAf,OACzB,kBAACH,GAAD,KACE,kBAACD,GAAD,CAAQpM,IHxBY,UGwBGyM,GAAG,IAAIC,KAAK,0CACjC,kBAAC,IAAD,CAAiBjF,KAAMkF,KAAahF,KAAK,OACzC,yCAEF,kBAACyE,GAAD,CAAQpM,IH5BY,UG4BGiH,QAASuF,GAC9B,kBAAC,IAAD,CAAiB/E,KAAM9D,EAAaiJ,IAAU5C,IAAYrC,KAAK,OAC/D,8BAAOhE,EAAa,OAAS,eCtDtBkJ,GAAS,WAkEpB,OAjEAlN,qBAAU,WACR,IAAIoD,EACAtE,EACEE,EAAiB,SAAAC,GAAM,OAAKH,EAAaI,OAAOC,sBAAsBF,IACtEG,EAAiB,kBAAON,EAAaI,OAAOG,qBAAqBP,IAGjEqO,EAAY,SAAZA,IAAmB,IAAD,EACWjO,OAAzBkO,EADc,EACdA,YACFC,EAFgB,EACDC,QACQlK,EACvBmK,EAAYF,EAAa,EACzBG,EAAWH,EAAaI,SAASC,KAAKC,aAAeP,GACrCG,IAAcC,GAGlCtO,OAAO0O,OAAO,EAAGP,GACjBrO,EAAemO,IAEf/N,KAlBU,EAsD0CR,GAhClC,SAAA6H,GACpB,IACMoH,EADiB3O,OAAOkO,YACW,EACnCU,EAAkBrH,EAAMsH,QACxBC,EAAmBF,EAAkBD,EACrCI,EAAsBH,EAAoC,EAAlBD,EACxCK,EAAkBL,EAClBM,EAxBwB5O,QAAQT,GA0BhCsP,EAAmBD,KAAkBH,GAAoBC,GAE3DD,IAGF5K,IADoB8K,IADML,EAAkBC,GAAmBD,KAK7DI,IAGF7K,EADoB8K,IADMJ,EAAoC,EAAlBD,GAAuBA,KAVzCM,IAAiBH,GAAoBC,IAgB/DjP,EAAemO,GAGbiB,GACFhP,OAlDU,mBAsDPiP,EAtDO,KAsDgBC,EAtDhB,KAuDRC,EAAkBF,IAGxB,OAFAnP,OAAOsP,iBAAiB,WAAYD,GAE7B,WACLnP,IACAkP,IACApP,OAAOuP,oBAAoB,WAAYF,MAExC,IAEI,M,4oBC1CT,IAAMG,GAAcC,YAAH,KLnBQ,GAiCG,IA9BH,GAHA,GAiCG,IAhCH,IK6CnBC,GAAkB,kBAAMC,OACxBC,GAAuBF,GAEvBG,GAAwB,SAAAC,GAAK,OAAI,gBAAEC,EAAF,2BAAaD,IAAUC,IACxDC,GAAwB,SAACtO,EAAUuO,GAAX,OAAkBvO,EAASwO,UAAUL,GAAsBI,KACnFE,GAA6B,SAACC,EAAcH,GAAf,OACjCG,EAAaF,UAAUL,GAAsBI,KAEzCtJ,GAAyB,eAAC0J,EAAD,uDAAK,EAAGC,EAAR,uDAAY,EAAZ,qCAA0CD,EAA1C,cAAiDC,EAAjD,QAMzBC,GAA4B,SAAC7O,EAAUmL,EAAa2D,EAAYC,GAGpE,KAD0B5D,GAAe2D,GAAc3D,IAAgB2D,GAC/C,OAAO7J,GAG/B,IAAM+J,EAAiBV,GAAsBtO,EAAUmL,GACjD8D,EAAgBX,GAAsBtO,EAAU8O,GAEtD,OADsBE,IAAmBD,IAOZA,GAAeC,GAAkBD,GAAeE,KACjDF,GAAeC,GAAkBD,GAAeE,GASrE,SAAkCC,GACvC,IAEMC,EAAWD,EAFMF,EAAiBD,EACD,qBAAuB,0BAE3CK,EAA6BF,EAAxCG,UAA8BC,EAAUJ,EAAtBK,WACPC,EAA6BL,EAAxCE,UAA8BI,EAAUN,EAAtBI,WAI1B,OAAOtK,IAHSwK,EAAQH,GLtFA,GKsFyB,KACjCE,EAAQJ,GLvFA,GKuFyB,MAvBxBnK,IA2TdyK,GA9RH,WAAM,MAKgBxK,mBAAS,IAAI/C,IAAI,KALjC,mBAKTnC,EALS,KAKC2P,EALD,KAWVC,EAA2B3Q,EAAe0Q,GAXhC,EAasBzK,mBAAS,MAb/B,mBAaTiG,EAbS,KAaI0E,EAbJ,OAcoB3K,mBAAS,MAd7B,mBAcT4J,EAdS,KAcGgB,EAdH,KAeV9M,IAAmBmI,EACnB1D,EAAUzE,GAAkBhD,EAASE,IAAIiL,GAGzC4E,EAAmBC,uBAAY,kBAAMF,EAAc,QAAO,IAC1DG,EAAgBD,uBAAY,WAFFH,EAAe,MAI7CE,EAAiB,QAChB,CAACA,IAEEG,EAAe,SAAAzQ,GAAG,OACtBmQ,GAAyB,SAAA5P,GAAQ,OAAI,IAAImC,IAAJ,sBAAYnC,GAAZ,CAAsB,CAACgO,KAAmBvO,UAY3E0Q,EAAmBH,uBACvB,SAACzB,EAAI9O,GAAL,OAAamQ,GAAyB,SAAA5P,GAAQ,OAAI,IAAImC,IAAJ,sBAAYnC,GAAZ,CAAsB,CAACuO,EAAI9O,WAC7E,CAACO,IAGGoQ,EAA0BJ,uBAC9B,SAAAK,GACE,GAAIlF,IAAgBkF,EAApB,CAEA,IAAMC,EAAY,YAAOtQ,GAGnBuQ,EAFYjC,GAAsBgC,EAAcD,GAC/B/B,GAAsBgC,EAAcnF,GAErDqF,EAAa,CAACrF,EAAanL,EAASE,IAAIiL,IACxCsF,EAAe,IAAItO,IACvBmO,EAAaI,QAAO,SAACC,EAAD,GAAqB,IAAD,mBAAbpC,EAAa,KAAT9O,EAAS,KACtC,QAAQ,GACN,KAAK8O,IAAOpD,EACV,OAAOwF,EACT,KAAKpC,IAAO8B,EACV,MAAmB,sBACXM,GADDJ,EAAY,CACNC,EAAY,CAACjC,EAAI9O,IADX,CAEN,CAAC8O,EAAI9O,GAAM+Q,IAC1B,QACE,MAAM,GAAN,mBAAWG,GAAX,CAAgB,CAACpC,EAAI9O,QAExB,KAELmQ,EAAyBa,GACzBR,OAEF,CAACjQ,EAAUmL,EAAa8E,IAGpBW,EAAgC,sCAAI/R,EAAJ,yBAAIA,EAAJ,uBACpCgQ,GAAyB,WAAzB,eAA8B7O,IAA9B,OAA4CnB,KAzE9B,EA8EwBqG,mBAAS,IA9EjC,mBA8ETwJ,EA9ES,KA8EKmC,EA9EL,OAgFsC3L,mBAAS,MAhF/C,mBAgFT4L,EAhFS,KAgFY1F,EAhFZ,KAiFVC,EAA4B,kBAAMD,EAAuB,OAazD2F,EAAoB,WAAiC,IAAD,yDAAP,GAAtB1O,EAA6B,EAA7BA,OAAQC,EAAqB,EAArBA,UAC7B0O,EAAiB,CACrB3O,OAAQA,GAAUvC,EAAgCwC,EAAWtC,GAC7DsC,UAAWA,GAAaxC,EAAgCuC,EAAQrC,IAElE6Q,EAAgB,IAAI1O,IAAJ,sBAAYuM,GAAZ,CAA0B,CAACR,KAAwB8C,QAa/DC,EAAoBjB,uBACxB,SAAC9E,EAAQgG,GACP,IAAMC,EAAS,YAAOzC,GAChB0C,EAAY3C,GAA2B0C,EAAWjG,GAClDmG,EAAS,sBACVF,EAAUG,MAAM,EAAGF,IADT,CAEb,CAAClG,EAAQgG,IAFI,YAGVC,EAAUG,MAAMF,EAAY,KAEjCP,EAAgB,IAAI1O,IAAIkP,MAE1B,CAAC3C,IAOHtP,qBAAU,WAAO,IAAD,EL5GmB,SAAAmS,GAAW,IAAD,EACMC,IAAGC,MAAMF,EAAQ,CAAEG,mBAAmB,IAD5C,IACrCC,EAAG3R,OADkC,MACvB,GADuB,MACnB4R,EAAGlD,OADgB,MACD,GADC,EAEvCmD,EAAY,IAAI1P,IAAInC,EAAS0J,KAAI,SAACjE,EAAOkE,GAAR,MAAkB,CAAC,GAAD,OAAIA,GAASlE,OAChEqM,EAAU,IAAI3P,IAClBuM,EAAahF,KAAI,WAAsBC,GAAtB,uBAAEtH,EAAF,KAAUC,EAAV,WAAgC,CAAC,GAAD,OAAIqH,GAAS,CAAEtH,SAAQC,kBAEpEyP,EAAgBF,EAAUzK,MAAQ0K,EAAQ1K,KAEhD,MAAO,CACLpH,SAAU+R,EAAgBF,GAAa,GAAK3P,EAC5CwM,aAAcqD,EAAgBD,GAAW,GAAK1P,GKmGX4P,CAAsB1T,OAAO2T,SAASV,QAAjEvR,EADM,EACNA,SAAU0O,EADJ,EACIA,aAElBkB,EAAyB5P,GACzB6Q,EAAgBnC,KACf,IAEHtP,qBAAU,WACR,IAAMmS,EL/HyB,SAACvR,EAAU0O,GAC5C,IAAMwD,EAAU,YAAOlS,EAASI,UAC1B+R,EAAU,YAAOnS,EAASoS,QAC1BC,EAAW,YAAI3D,EAAatO,UAAUsJ,KAAI,gBAAGrH,EAAH,EAAGA,OAAQC,EAAX,EAAWA,UAAX,MAA2B,CACzE6P,EAAWG,QAAQjQ,GACnB8P,EAAWG,QAAQhQ,OAGrB,OAAOkP,IAAGe,UAAU,CAAEZ,EAAGO,EAAYN,EAAGS,GAAY,CAAEG,gBAAgB,IKuHrDC,CAAoBzS,EAAU0O,GAD/B,EAEuBpQ,OAAO2T,SAApCS,EAFM,EAENA,SAAUC,EAFJ,EAEIA,KAAMC,EAFV,EAEUA,SAClBC,EAAG,UAAMH,EAAN,aAAmBC,GAAnB,OAA0BC,GAA1B,OAAqCrB,GAE9CjT,OAAOwU,QAAQC,aAAa,GAAI,GAAIF,KACnC,CAAC7S,EAAU0O,IA/IE,MAqJoBxJ,oBAAS,GArJ7B,mBAqJT9B,EArJS,KAqJG4P,EArJH,KAwJVC,EAAejD,uBACnB,SAAAvL,GACE,IAAM6L,EAAY,YAAOtQ,GACnB+O,EAAcT,GAAsBgC,EAAc7L,GAClDgM,EAAY,sBACbH,EAAagB,MAAM,EAAGvC,IADT,YAEbuB,EAAagB,MAAMvC,EAAc,KAEtCa,EAAyB,IAAIzN,IAAIsO,MAEnC,CAACzQ,IAGGkT,EAAoBlD,uBACxB,SAAA9E,GACE,IAAMiG,EAAS,YAAOzC,GAChB0C,EAAY3C,GAA2B0C,EAAWjG,GAClDmG,EAAS,sBAAOF,EAAUG,MAAM,EAAGF,IAA1B,YAAyCD,EAAUG,MAAMF,EAAY,KACpFP,EAAgB,IAAI1O,IAAIkP,MAE1B,CAAC3C,IAGGyE,EAA4BnT,EAASoH,KAAO,EAC5CgM,EAAgC1E,EAAatH,KAAO,EAEpDiM,EAAiC,WACrC,IAAMC,EAAkB,YAAI5E,EAAatO,UAAUsQ,QACjD,SAACC,EAAD,OAAQtO,EAAR,EAAQA,OAAQC,EAAhB,EAAgBA,UAAhB,4BAAoCqO,GAApC,CAAyCtO,EAAQC,MACjD,IAGF,OAAO,SAAAmC,GAAQ,OAAI6O,EAAgBhJ,SAAS7F,IANP,GASvC,OACE,oCACE,kBAACqJ,GAAD,MACA,kBAAC9B,GAAW,CAAE5I,aAAY6I,mBAxCH,kBAAM+G,GAAe5P,MAyC3CJ,GAAkB,kBAAC,GAAD,MACnB,kBAACuQ,EAAA,EAAD,CAAiBC,UAAWlP,IACzB,YAAItE,GAAU0J,KAAI,WAAkBqF,GAAlB,uBAAEtK,EAAF,KAAYhF,EAAZ,YACjB,kBAACoH,EAAA,EAAD,CAAe+C,IAAKnF,EAAUuC,QL3Qf,IK2QmCC,WAAW,UAC3D,kBAAC1C,GAAD,eACEqF,IAAKnF,G,2VADP,EAGIA,WACAhF,MACAuD,iBACAI,cAtHsC,SAAAqB,GAClD,GAAKqM,EAAL,CACA,IAAMI,EAAcxC,EAAaxO,IAAI4Q,GAC/B2C,EAAUvC,EAAY7O,SAAWoC,EACjCiP,EAAaxC,EAAY5O,YAAcmC,EACvChB,EAAwBgQ,GAAWC,EAGzC,MAAO,CAAEjQ,wBAAuBN,qBAFHM,GAAyBqN,IAiHvC6C,CAA4ClP,IAPnD,CASEf,oBACEyP,IAA8BE,EAA8B5O,GAE9DC,aAAcyL,EACdxL,gBAAiBkL,EACjBjL,eAAgBkL,EAChBjL,eAAgBkL,EAChBjL,cAAemL,EACflL,WAAYqL,EACZpL,aAAciO,EACdhO,uBAAwB2L,EACtBzF,EACA2D,EACAC,UAKR,oCAKE3L,EAKE,8BAEA,kBAACyD,EAAA,EAAD,CAAeC,eAAa,EAACC,IAAK3D,EAAY4D,QLnTjC,IKmTqDC,WAAW,WAC3E,kBAACO,GAAD,cACM,CAAEC,WADR,CAEEC,YAjNiB,WAAO,IAAD,EACf,YAAI1H,GAAU4T,OAAS,GAAlCC,EAD0B,oBAEnC3D,EAAa2D,GLhHI,SKgUL9O,WA7Mc,WAC1BmL,EAAazI,GACbwI,WAiNE,kBAACsD,EAAA,EAAD,CAAiBC,UAAW1K,IACzB,YAAI4F,GAAchF,KAAI,mCAAEwB,EAAF,YAAY7I,EAAZ,EAAYA,OAAQC,EAApB,EAAoBA,UAApB,OACrB,kBAACuE,EAAA,EAAD,CAAe+C,IAAKsB,EAAQlE,QL/Tb,IK+TiCC,WAAW,eACzD,kBAACgE,GAAD,eACErB,IAAKsB,GACD,CACFA,SACA7I,SACAC,YACA6I,cACA1D,UACAzE,iBACAI,aACAgI,yBACAC,6BAXJ,CAaE3H,oBAAqB0P,EACrB5K,QAASxI,EAASE,IAAImC,GACtBoG,WAAYzI,EAASE,IAAIoC,GACzByC,WAAYkM,EACZjM,aAAckO,SAIpB,oCACG9P,EACC,8BAEA,kBAACyD,EAAA,EAAD,CAAeC,eAAa,EAACC,IAAK3D,EAAY4D,QLzVjC,IKyVqDC,WAAW,WAC3E,kBAACyE,GAAD,cACM,CAAEP,cAAa1D,UAASzE,kBAD9B,CAEE0E,YA7KsB,WAAO,IAAD,EACb,YAAIgH,GAAckF,OAAS,GAA7C5C,EAD+B,oBAExCD,EAAkBC,IA4KNjM,WAzK6B,SAAAiM,GACzCD,EAAkBC,GAClBf,aClNJ6D,IAASC,OAAO,kBAAC,GAAD,MAASlH,SAASmH,eAAe,W","file":"static/js/main.54607f47.chunk.js","sourcesContent":["import React, { useEffect, useRef } from \"react\";\n\nexport const LoadControl = (callback) => {\n  // Throttler - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  //\n  let throttleId;\n  const createThrottle = (action) => (throttleId = window.requestAnimationFrame(action));\n  const removeThrottle = () => (throttleId = window.cancelAnimationFrame(throttleId));\n  const checkIsThrottling = () => Boolean(throttleId);\n\n  // Debouncer - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  //\n  const DEBOUNCE_MILLISECONDS = 100;\n  let debounceId;\n  const createDebounce = (...args) =>\n    (debounceId = window.setTimeout(() => callback(...args), DEBOUNCE_MILLISECONDS));\n  const removeDebounce = () => window.clearTimeout(debounceId);\n\n  // Depending on the current \"load controlled\" situation we want to begin a\n  // throttle sequence or defer the callback to a debounced scenario.\n  const createLoadControl = () => (...args) => {\n    if (checkIsThrottling()) {\n      // If we are already throttling - the callback is STILL IMPORTANT. If the\n      // throttle finishes but misses the final user input then we could potential\n      // have the <input /> and <Swatch /> UI out of sync. In this case we create\n      // a debounced, which will wait a period of time then run the supplied callback.\n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n      // We do not want to stack callbacks and have them ALL run once their timeout\n      // expires. We ONLY care about the last supplied callback. In that regard,\n      // we destroy the preceding debounced setup and create a new one. This keep\n      // pushing out the time to run the callback while the thriller is still\n      // running.\n      removeDebounce();\n      createDebounce(...args);\n    } else {\n      // If there is NO throttler instance then this is a \"fresh\" call to \"load\n      // control\". Here we run the callback inside of a requestAnimationCall so\n      // that its run when the browser has the capability to do so.\n      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n      // We ONLY want to run ONE callback per CPU cycle. In that regard we STOP\n      // callbacks from stacking by creating and removing the RAF reference so\n      // that ONLY one is running at a time BEFORE and AFTER the callback runs.\n      createThrottle(() => {\n        callback(...args);\n        removeThrottle();\n      });\n    }\n  };\n\n  const cleanUpLoadControl = () => {\n    removeThrottle();\n    removeDebounce();\n  };\n\n  return [createLoadControl, cleanUpLoadControl];\n};\n\nexport const useLoadControl = (callback) => {\n  const loadControl = useRef();\n\n  useEffect(() => {\n    const [createLoadControl, cleanUpLoadControl] = LoadControl(callback);\n    loadControl.current = createLoadControl();\n    return cleanUpLoadControl;\n  }, []);\n\n  // If the useEffect system has not been setup yet (happens in the first tick(s))\n  // then we just fall back to the vanilla callback until the \"load control\"\n  // enrichment is complete.\n  return loadControl.current || callback;\n};\n","import { css, keyframes } from \"styled-components\";\nimport tinyColor from \"tinycolor2\";\nimport qs from \"qs\";\n\nexport const createSwatch = hex => tinyColor(hex);\n\nexport const SPACE_300 = 4;\nexport const SPACE_400 = 8;\nexport const SPACE_500 = 16;\nexport const SPACE_600 = 24;\nexport const SPACE_700 = 32;\nexport const SPACE_800 = 40;\n\nexport const SWATCH_WIDTH = 80;\nexport const BORDER_WIDTH = 3;\nexport const FOCUS_WIDTH = 3;\nexport const COMP_WIDTH_LARGE = SPACE_500 * 16;\nexport const COMP_HEIGHT_LARGE = SPACE_500 * 18;\nexport const COMP_WIDTH_SMALL = COMP_WIDTH_LARGE;\nexport const COMP_HEIGHT_SMALL = SPACE_500 * 14;\n\nexport const BORDER_RADIUS = 4;\n\nexport const WHITE = \"#fff\";\nexport const BLACK = \"#000\";\n\nexport const GRAY_100 = \"#EAF0EE\";\nexport const GRAY_300 = \"#c8d5d1\";\nexport const GRAY_500 = \"#8DA79F\";\nexport const GRAY_700 = \"#5c716b\";\nexport const GRAY_900 = \"#40504C\";\n\nexport const SPEED_500 = 250;\nexport const SPEED_700 = 500;\n\nexport const SCALE_200 = 0.5;\nexport const SCALE_300 = 0.8;\nexport const SCALE_400 = 0.9;\nexport const SCALE_500 = 1;\nexport const SCALE_600 = 1.1;\n\nexport const VIEWPORT_500 = 768;\n\nexport const FOCUS_SHADOW_500 = `0 0 13px ${FOCUS_WIDTH}px ${createSwatch(BLACK).setAlpha(0.25)}`;\n\nexport const LUMINANCE_SHADOW_500 = `inset 0 0 0 ${BORDER_WIDTH}px ${createSwatch(BLACK).setAlpha(\n  0.1\n)}`;\n\nexport const findColorComplementFromSwatches = (compareId, swatches) => {\n  const compareHex = swatches.get(compareId);\n  const hexes = [...swatches.values()];\n  const complementHex = tinyColor.mostReadable(compareHex, hexes).toHexString();\n  const [complementId] = [...swatches.entries()].find(([, hex]) => hex === complementHex);\n\n  return complementId;\n};\n\nexport const checkHasLowLuminance = hex => createSwatch(hex).getLuminance() > 0.9;\n\nconst updateLuminanceStatic = (lighten, darken) => (isLuminant, luminance) =>\n  isLuminant ? lighten : darken;\n\nconst updateLuminanceDynamic = percentage => (isLuminant, luminance) => {\n  const offset = (luminance * percentage) / 100;\n  return isLuminant ? Math.max(luminance - offset, 0) : Math.min(luminance + offset, 100);\n};\n\nconst createColorCompanion = (createUpdate, alpha = 1) => hex => {\n  const prevSwatch = createSwatch(hex).toHsl();\n  const { l: luminanceBefore } = prevSwatch;\n  const isLuminant = luminanceBefore > 0.6;\n  const luminanceAfter = createUpdate(isLuminant, luminanceBefore);\n  const nextSwatch = { ...prevSwatch, l: luminanceAfter };\n\n  return tinyColor(nextSwatch)\n    .setAlpha(alpha)\n    .toString();\n};\n\nexport const createOffsetColor = createColorCompanion(updateLuminanceStatic(0.2, 0.8));\nexport const createTargetColor = hex => hex;\nexport const createFocusColor = createColorCompanion(updateLuminanceStatic(0.3, 0.7), 0.5);\nexport const createActiveColor = createColorCompanion(updateLuminanceStatic(0.5, 0.5), 1);\n\nexport const createFocusborder = hex => `0 0 0 ${FOCUS_WIDTH}px ${createFocusColor(hex)}`;\nexport const createFocusState = hex => createFocusborder(hex);\nexport const createFocusStateWithShadow = hex => `${FOCUS_SHADOW_500}, ${createFocusborder(hex)}`;\n\nexport const resetList = css`\n  list-style: none;\n  margin: 0;\n  padding: 0;\n`;\n\nexport const positionAbsolute = css`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n`;\n\nconst defaultSwatches = new Map([\n  [\"1\", createSwatch(\"rgb(88, 213, 255)\").toHexString()],\n  [\"2\", createSwatch(\"rgb(246, 199, 163)\").toHexString()],\n  [\"3\", createSwatch(\"rgb(240, 124, 125)\").toHexString()],\n  [\"4\", createSwatch(\"rgb(218, 68, 93)\").toHexString()],\n  [\"5\", createSwatch(\"rgb(38, 51, 56)\").toHexString()]\n]);\n\nconst defaultCompositions = new Map([\n  [\"1\", { baseId: \"5\", contentId: \"1\" }],\n  [\"2\", { baseId: \"4\", contentId: \"2\" }],\n  [\"3\", { baseId: \"2\", contentId: \"5\" }]\n]);\n\nexport const convertStateToQuery = (swatches, compositions) => {\n  const swatchFlat = [...swatches.values()];\n  const swatchKeys = [...swatches.keys()];\n  const compFlat = [...compositions.values()].map(({ baseId, contentId }) => [\n    swatchKeys.indexOf(baseId),\n    swatchKeys.indexOf(contentId)\n  ]);\n\n  return qs.stringify({ s: swatchFlat, c: compFlat }, { addQueryPrefix: true });\n};\n\nexport const convertStateFromQuery = search => {\n  const { s: swatches = [], c: compositions = [] } = qs.parse(search, { ignoreQueryPrefix: true });\n  const swatchMap = new Map(swatches.map((value, index) => [`${index}`, value]));\n  const compMap = new Map(\n    compositions.map(([baseId, contentId], index) => [`${index}`, { baseId, contentId }])\n  );\n  const hasUserConfig = swatchMap.size || compMap.size;\n\n  return {\n    swatches: hasUserConfig ? swatchMap || [] : defaultSwatches,\n    compositions: hasUserConfig ? compMap || [] : defaultCompositions\n  };\n};\n\nexport const deleteKeyframes = offset => keyframes`\n  from {\n    transform: rotate(-${offset}deg);\n  }\n\n  to {\n    transform: rotate(${offset}deg);\n  }\n`;\n\nexport const deleteAnimation = offset => css`\n  transform-origin: right top;\n  animation: 0.1s infinite alternate ${deleteKeyframes(offset)};\n  animation-timing-function: ease-in-out;\n`;\n","import React, { memo, useState, useEffect, useRef, useCallback } from \"react\";\nimport { CSSTransition } from \"react-transition-group\";\nimport styled, { css } from \"styled-components\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faPlus, faTimes } from \"@fortawesome/free-solid-svg-icons\";\nimport { useLoadControl } from \"./LoadControl\";\nimport {\n  SWATCH_WIDTH,\n  BORDER_WIDTH,\n  BORDER_RADIUS,\n  WHITE,\n  BLACK,\n  GRAY_300,\n  GRAY_500,\n  GRAY_900,\n  SPEED_500,\n  SPEED_700,\n  SCALE_300,\n  SCALE_400,\n  SCALE_500,\n  SCALE_600,\n  SPACE_300,\n  SPACE_400,\n  SPACE_500,\n  SPACE_600,\n  SPACE_700,\n  LUMINANCE_SHADOW_500,\n  createSwatch,\n  createOffsetColor,\n  createTargetColor,\n  createFocusState,\n  createActiveColor,\n  createFocusStateWithShadow,\n  checkHasLowLuminance,\n  resetList,\n  positionAbsolute,\n  deleteAnimation,\n} from \"./utils\";\n\nconst SwatchList = styled.ul`\n  ${resetList}\n  display: grid;\n  grid-gap: 0;\n  grid-template-rows: repeat(auto-fill, ${SWATCH_WIDTH}px);\n  grid-template-columns: repeat(auto-fill, ${SWATCH_WIDTH}px);\n\n  /** Regardless of content we ALWAYS conform to the rigid grid system dimensions. */\n  > * {\n    height: ${SWATCH_WIDTH}px;\n    width: ${SWATCH_WIDTH}px;\n  }\n`;\n\nconst UserItem = styled.div`\n  ${positionAbsolute}\n  background: ${({ hex }) => hex};\n  /* pointer-events: none; */\n  transition-duration: ${SPEED_700}ms, ${SPEED_500}ms, ${SPEED_700}ms, ${SPEED_700}ms;\n  transition-property: background, box-shadow, transform, border;\n\n  ${({ hex, isUserDragging, isDragged, isAboutToDrag, shouldSwatchRegress, isDeleting }) => {\n    let styles = \"\";\n\n    /**\n     * If a swatch color the user has selected has VERY LOW luminance (white or\n     * close to white) then the swatch will blend into the application background\n     * (and effectively dissapear).\n     *\n     * In that regard, we add a slightly darker border around the color to\n     * differentiate it from the background (if it needs it).\n     */\n    if (checkHasLowLuminance(hex)) {\n      styles += `\n        &:after {\n          ${positionAbsolute}\n          border-radius: 4px;\n          box-shadow: ${LUMINANCE_SHADOW_500};\n          content: \"\";\n          display: block;\n          transition: opacity ${SPEED_500}ms;\n        }\n      `;\n    }\n\n    if (isDragged || isUserDragging || isAboutToDrag || shouldSwatchRegress || isDeleting) {\n      styles += `\n        border-radius: ${BORDER_RADIUS}px;\n      `;\n    }\n\n    if (isUserDragging || isDeleting) {\n      styles += `\n        transform: scale(${SCALE_300});\n      `;\n    }\n\n    /**\n     * We want the original location where the swatch was dragged from to be an\n     * \"empty\" slot (by default it just sits there).\n     *\n     * + If we change `opacity: 0;` then that ALSO changes the dragged item\n     *   attached to the users mouse position.\n     *\n     * + Changing `background: white;` ONLY changes the placeholder \"dormant\"\n     *   swatch =)\n     */\n    if (isDragged && isUserDragging) {\n      styles += `\n        background: ${WHITE};\n      `;\n    }\n\n    /**\n     * The browser will take a \"snapshot\" or the dragged swatch IMMEDIATELY after\n     * dragging starts. The \"snapshot\" is a square around the DOM element and\n     * crops out anything NOT in that box (like `outline` and `box-shadow`). In\n     * that regard we need to have the dragging swatch BEFORE dragging starts.\n     *\n     * To do this we remove and `transition-duration` (so that things happen\n     * immediately - getting caught half way through a transition looks disjointed)\n     * and change the following:\n     *\n     * + `scale` shrink the main item (including `:focus` `box-shadow`) INSIDE\n     *   the crop box. This actually look pretty good as it simulates an \"on press\"\n     *   aesthetic.\n     *\n     * + Remove the drop shadow as it bleeds off the swatch crop area and can be\n     *   seen in the swatch rounded corners.\n     */\n    if (isAboutToDrag) {\n      styles += `\n        box-shadow: ${({ hex }) => createFocusState(hex)} !important;\n        transition-duration: 0ms;\n        transform: scale(${SCALE_400});\n      `;\n    }\n\n    return css`\n      ${styles}\n    `;\n  }}\n`;\n\nconst swatchActiveState = css`\n  z-index: 10;\n\n  ${UserItem} {\n    box-shadow: ${({ hex }) => createFocusStateWithShadow(hex)};\n    border-radius: ${BORDER_RADIUS}px;\n    outline: 0;\n\n    &:after {\n      opacity: 0;\n    }\n  }\n`;\n\nconst DragHitBox = styled.div`\n  position: relative;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n  /**\n   * When an item is being dragged we send it to the BACK so that ALL other\n   * swatches can overlap when the \"recording\" animation is running. The dragging\n   * swatch is also completely white and therefore CANNOT reside on top of\n   * anything else.\n   */\n  z-index: ${({ isDragged }) => (isDragged ? \"0\" : \"1\")};\n\n  ${({ isUserDragging, isDeleting }) =>\n    !isUserDragging &&\n    !isDeleting &&\n    /**\n     * Do NOT show these interaction states on ANY swatches when the user is\n     * dragging as swatches will all be changing their `:hover` states on/off\n     * throughout the dragging process.\n     */\n    css`\n      &:focus-within,\n      &:hover {\n        ${swatchActiveState}\n      }\n    `}\n\n  ${({ shouldSwatchRegress }) =>\n    shouldSwatchRegress &&\n    css`\n      opacity: 0.25;\n      transform: scale(${SCALE_300});\n    `}\n\n  ${({ shouldSwatchPronounce }) => shouldSwatchPronounce && swatchActiveState}\n\n  ${({ isDeleting, hasCapacityToDelete }) =>\n    isDeleting && hasCapacityToDelete && deleteAnimation(2)}\n\n  /** React CSSTransition animation property when an item is in its DORMANT state. */\n  &.swatch-enter,\n  &.swatch-exit,\n  &.swatch-exit-active {\n    opacity: 0;\n    transform: scale(0);\n  }\n\n  /** React CSSTransition animation property when an item is in its ACTIVE state. */\n  &.swatch-enter-active,\n  &.swatch-enter-done {\n    opacity: 1;\n    transform: scale(${SCALE_500});\n  }\n`;\n\nconst ReorderTransformation = styled.div`\n  ${positionAbsolute}\n  transition: ${SPEED_500}ms;\n\n  ${({ reorderTransform }) =>\n    css`\n      ${reorderTransform}\n    `}\n\n  ${({ isUserDragging }) => {\n    /*\n     * When a users is dragging a `<Swatch />` we want the \"re-order\" animation\n     * (simulated via CSS `transform`'s) to run.\n     *\n     * When however, the user drops a `<Swatch />` we want the items to \"re-order\"\n     * in the DOM (hard-coded NOT simulated). In that regard, if we are still\n     * running `transition`s on the now redundant `transform`'s then we get a\n     * flicker as the `<Swatch />` move back to their dormant state. When we apply\n     * NO `transition` the drop effect feel \"solid\".\n     */\n    switch (isUserDragging) {\n      case true:\n        return css`\n          transition-property: transform;\n        `;\n      default:\n        return css`\n          transition-property: none;\n        `;\n    }\n  }}\n`;\n\nexport const AddItem = styled.li`\n  /** Force contents to take up ALL of the \"cells\" x/y space. */\n  display: grid;\n  padding: ${SPACE_400}px;\n  position: relative;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n\n  /** React CSSTransition animation property when the add <button /> is in NOT ACTIVE. */\n  &.addItem-enter,\n  &.addItem-exit {\n    opacity: 0;\n    transform: scale(${SCALE_300});\n  }\n\n  /** React CSSTransition animation property when the add <button /> is in IS ACTIVE. */\n  &.addItem-enter-active {\n    opacity: 1;\n    transform: scale(${SCALE_500});\n  }\n`;\n\nexport const AddButton = styled.button`\n  align-self: stretch;\n  appearance: none;\n  border: ${BORDER_WIDTH}px solid ${({ hex }) => createOffsetColor(hex)};\n  border-radius: ${BORDER_RADIUS}px;\n  color: ${({ hex }) => createOffsetColor(hex)};\n  cursor: pointer;\n  display: block;\n  font-family: sans-serif;\n  font-weight: bold;\n  font-size: 14px;\n  height: 100%;\n  justify-self: stretch;\n  text-transform: uppercase;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: box-shadow, background, opacity, transform, width, height;\n  width: 100%;\n  outline: 0;\n\n  ${({ isTargeted }) =>\n    isTargeted\n      ? css`\n          background: ${({ hex }) => createTargetColor(hex)};\n          /* transform: scale(${SCALE_600}); */\n          transform: translate(-${SPACE_300}px, -${SPACE_300}px);\n          width: calc(100% + ${SPACE_400}px);\n          height: calc(100% + ${SPACE_400}px);\n        `\n      : css`\n          background: ${({ hex }) => hex};\n          /* transform: scale(${SCALE_300}); */\n        `};\n\n  &:focus,\n  &:hover {\n    box-shadow: ${({ hex }) => createFocusStateWithShadow(hex)};\n  }\n\n  &:active {\n    background: ${({ hex }) => createActiveColor(hex)};\n  }\n`;\n\nconst Input = styled.input`\n  ${positionAbsolute}\n  appearance: none;\n  opacity: 0;\n`;\n\nexport const DeleteButton = styled(AddButton)`\n  align-items: center;\n  display: flex;\n  height: ${SPACE_700}px;\n  justify-content: center;\n  position: absolute;\n  right: 0;\n  top: 0;\n  width: ${SPACE_700}px;\n  max-width: ${SPACE_700}px;\n\n  /** React CSSTransition animation property when the add <button /> is in NOT ACTIVE. */\n  &.deleteItem-enter,\n  &.deleteItem-exit {\n    opacity: 0;\n    transform: translate(${SPACE_500}px, -${SPACE_500}px) scale(${SCALE_300});\n  }\n\n  /** React CSSTransition animation property when the add <button /> is in IS ACTIVE. */\n  &.deleteItem-enter-active,\n  &.deleteItem-enter-done {\n    opacity: 1;\n    transform: translate(${SPACE_500}px, -${SPACE_500}px) scale(${SCALE_500});\n  }\n`;\n\nexport const Swatches = SwatchList;\n\nexport const UserSwatch = memo(\n  ({\n    swatchId,\n    hex,\n    handleChange,\n    handleDragStart,\n    handleDragOver,\n    handleDragExit,\n    handleDragEnd,\n    handleDrop,\n    isUserDragging,\n    isDeleting,\n    handleDelete,\n    hasCapacityToDelete,\n    createReorderTransform,\n    shouldSwatchPronounce,\n    shouldSwatchRegress,\n  }) => {\n    const [isDragged, setIsDragged] = useState(false);\n    const [isAboutToDrag, setIsAboutToDrag] = useState(false);\n    const swatchRef = useRef(null);\n\n    /**\n     * We are \"load controling\" the color input change to our `swatch` global state.\n     * Throttling/Debouncing causes the swatch hex to hang on the current value\n     * until the callback finally updates. This \"hanging\" makes the native color\n     * `<input />` constantly revert back to the swatch hex rather than the users\n     * current selection.\n     *\n     * In that regard, we need to keep a local reference to what the user has\n     * selected as their \"next\" hex choice so that the UI responds with a snappy\n     * experience.\n     */\n    const [inputValue, setInputValue] = useState(hex);\n    const handleLoadControledChange = useLoadControl((value) => handleChange(swatchId, value));\n\n    return (\n      <DragHitBox\n        {...{\n          isDragged,\n          isUserDragging,\n          hex,\n          shouldSwatchPronounce,\n          shouldSwatchRegress,\n          isDeleting,\n          hasCapacityToDelete,\n        }}\n        draggable={!isDeleting}\n        ref={swatchRef}\n        onDragStart={(event) => {\n          setIsAboutToDrag(false);\n          /*\n           * Even though we are setting the drag n drop state through React Firefox\n           * will not initialise a DnD scenario without setting the `dataTransfer`.\n           */\n          event.dataTransfer.setData(\"text/plain\", \"banana\");\n\n          /**\n           * Set the drag image that will \"stick\" to the users mouse position during\n           * the entire drag sequence.\n           */\n          const offset = SWATCH_WIDTH / 2;\n          event.dataTransfer.setDragImage(swatchRef.current, offset, offset);\n\n          setIsDragged(true);\n          handleDragStart(swatchId);\n        }}\n        onDragEnd={() => {\n          setIsDragged(false);\n          handleDragEnd();\n        }}\n        onDragOver={(event) => {\n          handleDragOver(swatchId);\n          /*\n           * MDN suggests applying `preventDefault` on specific DnD event hooks.\n           * @see https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Handle_the_drop_effect\n           */\n          event.preventDefault();\n        }}\n        onDragLeave={handleDragExit}\n        onDrop={(event) => {\n          setIsDragged(false);\n          handleDrop(swatchId);\n          /*\n           * MDN suggests applying `preventDefault` on specific DnD event hooks.\n           * @see https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Handle_the_drop_effect\n           */\n          event.preventDefault();\n        }}\n        onPointerDown={isDeleting ? undefined : () => setIsAboutToDrag(true)}\n        onPointerUp={isDeleting ? undefined : () => setIsAboutToDrag(false)}\n        onClick={() => {\n          /**\n           * Addresses an iOS issue where the native color input would not trigger\n           * focus when nested inside the drag area (and all of its own touch\n           * listeners). In that regard when the main wrapper is \"clicked\" we give\n           * focus to the nested <input />.\n           */\n          const input = swatchRef.current.querySelector(\"input\");\n          input && input.focus();\n        }}\n      >\n        <ReorderTransformation\n          {...{ isDragged, isUserDragging }}\n          reorderTransform={createReorderTransform(swatchRef.current)}\n        >\n          <UserItem\n            {...{\n              hex,\n              isDragged,\n              isUserDragging,\n              isAboutToDrag,\n              shouldSwatchRegress,\n              isDeleting,\n            }}\n          >\n            <CSSTransition\n              unmountOnExit\n              in={isDeleting && hasCapacityToDelete}\n              timeout={SPEED_700}\n              classNames=\"deleteItem\"\n            >\n              <DeleteButton hex={GRAY_300} onClick={() => handleDelete(swatchId)}>\n                <FontAwesomeIcon icon={faTimes} size=\"1x\" />\n              </DeleteButton>\n            </CSSTransition>\n          </UserItem>\n          {!isDeleting && (\n            <Input\n              type=\"color\"\n              value={inputValue}\n              onChange={(event) => {\n                const { value } = event.target;\n                setInputValue(value);\n                handleLoadControledChange(value);\n              }}\n            />\n          )}\n        </ReorderTransformation>\n      </DragHitBox>\n    );\n  }\n);\n\nexport const AppendSwatch = memo(({ dragHex, handleClick, handleDrop }) => {\n  const [isTargeted, setIsTargeted] = useState(false);\n\n  return (\n    <AddItem>\n      <AddButton\n        {...{ isTargeted }}\n        hex={isTargeted && dragHex ? dragHex : GRAY_300}\n        onClick={handleClick}\n        onDragOver={(event) => {\n          /*\n           * An `onDragOver` event MUST be present in order for a `onDrop` to\n           * trigger!\n           */\n          setIsTargeted(true);\n          event.preventDefault();\n        }}\n        onDragLeave={() => setIsTargeted(false)}\n        onPointerEnter={() => setIsTargeted(true)}\n        onPointerLeave={() => setIsTargeted(false)}\n        onDrop={(event) => {\n          handleDrop();\n          setIsTargeted(false);\n          /*\n           * MDN suggests applying `preventDefault` on specific DnD event hooks.\n           * @see https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Handle_the_drop_effect\n           */\n          event.preventDefault();\n        }}\n      >\n        <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n      </AddButton>\n    </AddItem>\n  );\n});\n","import React, { memo, useEffect, useRef, useState } from \"react\";\nimport { CSSTransition } from \"react-transition-group\";\nimport styled, { css } from \"styled-components\";\nimport tinyColor from \"tinycolor2\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faPlus, faCheck, faTimes } from \"@fortawesome/free-solid-svg-icons\";\nimport {\n  faCheckCircle,\n  faCalendarAlt,\n  faCommentDots,\n  faStar,\n  faTrashAlt\n} from \"@fortawesome/free-regular-svg-icons\";\nimport {\n  BLACK,\n  GRAY_300,\n  GRAY_900,\n  COMP_HEIGHT_LARGE,\n  COMP_WIDTH_LARGE,\n  COMP_HEIGHT_SMALL,\n  COMP_WIDTH_SMALL,\n  BORDER_RADIUS,\n  BORDER_WIDTH,\n  SCALE_200,\n  SCALE_300,\n  SCALE_500,\n  SCALE_600,\n  SPACE_400,\n  SPACE_500,\n  SPACE_600,\n  SPACE_800,\n  SPEED_500,\n  SPEED_700,\n  VIEWPORT_500,\n  LUMINANCE_SHADOW_500,\n  createSwatch,\n  checkHasLowLuminance,\n  resetList,\n  positionAbsolute,\n  deleteAnimation\n} from \"./utils\";\nimport { AppendSwatch, AddItem, AddButton, DeleteButton } from \"./Swatch\";\n\nconst CompList = styled.ul`\n  ${resetList}\n  display: grid;\n  grid-gap: ${SPACE_500}px;\n  grid-template-columns: repeat(auto-fit, minmax(${COMP_WIDTH_LARGE}px, auto));\n  /* grid-template-rows: repeat(auto-fill, minmax(${COMP_HEIGHT_LARGE}px, auto)); */\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    grid-gap: ${SPACE_600}px;\n  }\n\n  > * {\n    min-height: ${COMP_HEIGHT_SMALL}px;\n    min-width: ${COMP_WIDTH_SMALL}px;\n\n    @media screen and (min-width: ${VIEWPORT_500}px) {\n      min-height: ${COMP_HEIGHT_LARGE}px;\n      min-width: ${COMP_WIDTH_LARGE}px;\n    }\n  }\n`;\n\nconst IconList = styled.ul`\n  ${resetList}\n\n  display: grid;\n  grid-template-columns: repeat(auto-fit, 1rem);\n  grid-gap: ${SPACE_500}px;\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    grid-gap: ${SPACE_600}px;\n  }\n`;\n\nconst DividerList = styled.ul`\n  ${resetList}\n  display: grid;\n  grid-gap: ${SPACE_500}px;\n  grid-template-columns: 1fr;\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    grid-gap: ${SPACE_600}px;\n  }\n`;\n\nconst ResultList = styled.ul`\n  ${resetList}\n  display: flex;\n  border-radius: 0 0 ${BORDER_RADIUS}px ${BORDER_RADIUS}px;\n  background: ${GRAY_300};\n  color: ${GRAY_900};\n  justify-content: space-between;\n  padding: ${SPACE_500}px;\n  font-family: monospace;\n  font-size: 24px;\n  font-weight: bold;\n  align-items: center;\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    padding: ${SPACE_600}px;\n  }\n\n  > * {\n    display: block;\n  }\n`;\n\nconst Character = styled.span`\n  opacity: ${({ children }) => (children === \"A\" ? 1 : 0.25)};\n`;\n\nconst UserItem = styled.div`\n  height: 100%;\n  width: 100%;\n  position: relative;\n  transition-property: opacity, transform;\n  transition-duration: ${SPEED_500}ms;\n  transform: scale(SCALE_500);\n\n  ${({ isUserDragging }) =>\n    isUserDragging &&\n    css`\n      opacity: 0.5;\n      pointer-events: none;\n      /* transform: scale(${SCALE_300}); */\n    `}\n\n  ${({ isDeleting, hasCapacityToDelete }) =>\n    isDeleting && hasCapacityToDelete && deleteAnimation(0.5)}\n`;\n\nconst Examples = styled.div`\n  /**\n   * Targeting the \"Base\" and \"Content\" hex values via CSS variables as the\n   * performance is more optimal than re-rendering a baked in value on every change.\n   *\n   * It also fixes an issue when referencing currentColor within a linear\n   * gradient (inconsistent in browsers).\n   */\n  --baseHex: ${({ baseHex }) => baseHex};\n  --contentHex: ${({ contentHex }) => contentHex};\n\n  border-radius: ${BORDER_RADIUS}px ${BORDER_RADIUS}px 0 0;\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-template-rows: auto;\n  grid-gap: ${SPACE_500}px;\n  background: var(--baseHex);\n  color: var(--contentHex);\n  padding: ${SPACE_500}px;\n  position: relative;\n  font-family: sans-serif;\n  transition: background ${SPEED_700}ms;\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    padding: ${SPACE_600}px;\n    grid-gap: ${SPACE_600}px;\n  }\n\n  > * {\n    display: block;\n  }\n\n  ${({ baseHex }) => {\n    /**\n     * Correspond with the <Swatch /> luminance aesthetic to differentiate VERY\n     * \"light\" colors from the application background.\n     */\n    if (checkHasLowLuminance(baseHex)) {\n      return css`\n        &:after {\n          ${positionAbsolute}\n          border-radius: ${BORDER_RADIUS}px ${BORDER_RADIUS}px 0 0;\n          box-shadow: ${LUMINANCE_SHADOW_500};\n          content: \"\";\n          display: block;\n        }\n      `;\n    }\n  }}\n`;\n\nconst SmallText = styled.span`\n  /**\n   * Force font size to be pixels (px) rather than something scaleable like rems\n   * so that we can force the \"worst case scenario\" when creating our color\n   * compositions.\n   */\n  display: block;\n  font-size: ${({ isBold }) => `${isBold ? 14 : 16}px`};\n  font-weight: ${({ isBold }) => (isBold ? \"bold\" : \"initial\")};\n`;\n\nconst Divider = styled.div`\n  border-radius: ${BORDER_RADIUS}px;\n  height: ${({ height }) => `${height}px`};\n  background-image: linear-gradient(to right, var(--contentHex), var(--baseHex));\n`;\n\nexport const Compositions = CompList;\n\nconst createContrastPercentage = (baseHex, contentHex) => {\n  const ratio = tinyColor.readability(baseHex, contentHex);\n  const percentage = (ratio / 21) * 100;\n\n  return Math.round(percentage);\n};\n\nconst createAccessibilityComparison = (baseHex, contentHex) => level =>\n  tinyColor.isReadable(baseHex, contentHex, { level, size: \"small\" });\n\nconst findAccessibilityLevel = (baseHex, contentHex) => {\n  const comparison = createAccessibilityComparison(baseHex, contentHex);\n\n  switch (true) {\n    case comparison(\"AAA\"):\n      return \"AAA\";\n    case comparison(\"AA\"):\n      return \"AA-\";\n    default:\n      return \"---\";\n  }\n};\n\nconst Icons = () => (\n  <div>\n    <IconList>\n      {[faCheckCircle, faCalendarAlt, faCommentDots, faStar, faTrashAlt].map((icon, index) => (\n        <li key={index}>\n          <FontAwesomeIcon {...{ icon }} />\n        </li>\n      ))}\n    </IconList>\n  </div>\n);\n\nconst Dividers = () => (\n  <div>\n    <DividerList>\n      {[1, 2, 4].map(height => (\n        <li key={height}>\n          <Divider {...{ height }} />\n        </li>\n      ))}\n    </DividerList>\n  </div>\n);\n\nconst Level = ({ children: level }) => {\n  const characters = level\n    .split(\"\")\n    .map((char, index) => <Character key={index}>{char}</Character>);\n\n  return <span>{characters}</span>;\n};\n\nconst DropAreas = styled.div`\n  ${positionAbsolute}\n  align-items: stretch;\n  display: grid;\n  grid-gap: ${SPACE_500}px;\n  justify-items: stretch;\n  padding: ${SPACE_600}px;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n\n  ${({ isUserDragging }) =>\n    !isUserDragging &&\n    css`\n      opacity: 0;\n      pointer-events: none;\n      transform: scale(${SCALE_600});\n    `}\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    grid-gap: ${SPACE_600}px;\n  }\n`;\n\nconst ResultIcon = styled(FontAwesomeIcon)`\n  transform: scale(${SCALE_600});\n`;\n\nconst Results = ({ baseHex, contentHex }) => {\n  const level = findAccessibilityLevel(baseHex, contentHex);\n  const icon = level.includes(\"AA\") ? faCheck : faTimes;\n  const percentage = createContrastPercentage(baseHex, contentHex);\n\n  return (\n    <div>\n      <ResultList>\n        <ResultIcon {...{ icon }} size=\"1x\" />\n        <Level>{level}</Level>\n        <span>{percentage}%</span>\n      </ResultList>\n    </div>\n  );\n};\n\nconst ItemWrapper = styled.li`\n  position: relative;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n\n  /** React CSSTransition animation property when an item is in its DORMANT state. */\n  &.composition-enter,\n  &.composition-exit,\n  &.composition-exit-active {\n    opacity: 0;\n    transform: scale(${SCALE_200});\n  }\n\n  /** React CSSTransition animation property when an item is in its ACTIVE state. */\n  &.composition-enter-active,\n  &.composition-enter-done {\n    opacity: 1;\n    transform: scale(${SCALE_500});\n  }\n`;\n\nconst AddCompositionButton = styled(AddButton)`\n  ${({ isActive }) =>\n    isActive\n      ? css`\n          opacity: 1;\n        `\n      : css`\n          opacity: 0;\n          pointer-events: none;\n        `}\n`;\n\nconst AddSlotButton = styled(AddButton)`\n  /**\n   * Hack for Safari, which does not confirm to positioning grid elements when\n   * the wrapper element has an opacity of 0. In that regard we staticky set\n   * the height of the slot 😩\n   */\n  min-height: 83px;\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    min-height: 115px;\n  }\n`;\n\nexport const UserComposition = memo(\n  ({\n    compId,\n    baseId,\n    contentId,\n    dragStartId,\n    baseHex,\n    contentHex,\n    dragHex,\n    isUserDragging,\n    isDeleting,\n    hasCapacityToDelete,\n    handleDelete,\n    handleDrop,\n    setActiveCompositionId,\n    removeActiveCompositionId\n  }) => {\n    const [isContentTargeted, setIsContentTargeted] = useState(false);\n    const [isBaseTargeted, setIsBaseTargeted] = useState(false);\n\n    return (\n      <ItemWrapper>\n        <UserItem\n          {...{ isUserDragging, isDeleting, hasCapacityToDelete }}\n          onPointerEnter={isDeleting ? undefined : () => setActiveCompositionId(compId)}\n          onPointerLeave={isDeleting ? undefined : removeActiveCompositionId}\n        >\n          <Examples {...{ baseHex, contentHex }}>\n            <SmallText>The quick brown fox,</SmallText>\n            <SmallText isBold>jumps over the lazy dog.</SmallText>\n            <Icons />\n            <Dividers />\n          </Examples>\n          <Results {...{ baseHex, contentHex }} />\n          <CSSTransition\n            unmountOnExit\n            in={isDeleting && hasCapacityToDelete}\n            timeout={SPEED_700}\n            classNames=\"deleteItem\"\n          >\n            <DeleteButton hex={GRAY_300} onClick={() => handleDelete(compId)}>\n              <FontAwesomeIcon icon={faTimes} size=\"1x\" />\n            </DeleteButton>\n          </CSSTransition>\n        </UserItem>\n        <DropAreas {...{ isUserDragging }}>\n          <AddSlotButton\n            hex={isContentTargeted ? dragHex : contentHex}\n            isTargeted={isContentTargeted}\n            onDragOver={event => {\n              setIsContentTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsContentTargeted(false)}\n            onDrop={event => {\n              handleDrop(compId, { contentId: dragStartId, baseId });\n              setIsContentTargeted(false);\n              setIsBaseTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n          <AddSlotButton\n            hex={isBaseTargeted ? dragHex : baseHex}\n            isTargeted={isBaseTargeted}\n            onDragOver={event => {\n              setIsBaseTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsBaseTargeted(false)}\n            onDrop={event => {\n              handleDrop(compId, { contentId, baseId: dragStartId });\n              setIsContentTargeted(false);\n              setIsBaseTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n        </DropAreas>\n      </ItemWrapper>\n    );\n  }\n);\n\nexport const AppendComposition = memo(\n  ({ dragHex, dragStartId, handleClick, handleDrop, isUserDragging }) => {\n    const [isAddTargeted, setIsAddTargeted] = useState(false);\n    const [isContentTargeted, setIsContentTargeted] = useState(false);\n    const [isBaseTargeted, setIsBaseTargeted] = useState(false);\n\n    return (\n      <AddItem>\n        <DropAreas {...{ isUserDragging }}>\n          <AddSlotButton\n            hex={isContentTargeted ? dragHex : GRAY_300}\n            isTargeted={isContentTargeted}\n            onDragOver={event => {\n              setIsContentTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsContentTargeted(false)}\n            onDrop={event => {\n              handleDrop({ contentId: dragStartId });\n              setIsContentTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n          <AddSlotButton\n            hex={isBaseTargeted ? dragHex : GRAY_300}\n            isTargeted={isBaseTargeted}\n            onDragOver={event => {\n              setIsBaseTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsBaseTargeted(false)}\n            onDrop={event => {\n              handleDrop({ baseId: dragStartId });\n              setIsContentTargeted(false);\n              setIsBaseTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n        </DropAreas>\n        <AddCompositionButton\n          hex={GRAY_300}\n          isActive={!isUserDragging}\n          isTargeted={isAddTargeted}\n          onClick={handleClick}\n          onPointerEnter={() => setIsAddTargeted(true)}\n          onPointerLeave={() => setIsAddTargeted(false)}\n        >\n          <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n        </AddCompositionButton>\n      </AddItem>\n    );\n  }\n);\n","import React, { memo, useEffect, useRef, useState } from \"react\";\nimport styled, { css } from \"styled-components\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faTrashAlt, faTasks } from \"@fortawesome/free-solid-svg-icons\";\nimport { faGithubAlt } from \"@fortawesome/free-brands-svg-icons\";\nimport {\n  BLACK,\n  GRAY_300,\n  GRAY_900,\n  COMP_WIDTH,\n  COMP_HEIGHT,\n  BORDER_RADIUS,\n  BORDER_WIDTH,\n  SCALE_200,\n  SCALE_300,\n  SCALE_500,\n  SCALE_600,\n  SPACE_400,\n  SPACE_500,\n  SPACE_600,\n  SPACE_800,\n  SPEED_500,\n  SPEED_700,\n  LUMINANCE_SHADOW_500,\n  createSwatch,\n  checkHasLowLuminance,\n  resetList,\n  positionAbsolute\n} from \"./utils\";\nimport { AddButton } from \"./Swatch\";\n\nconst Button = styled(AddButton)`\n  display: inline-flex;\n  align-items: center;\n  width: auto;\n  padding: 0 ${SPACE_500}px;\n  text-decoration: none;\n\n  > *:nth-child(1n + 2) {\n    margin-left: ${SPACE_400}px;\n  }\n`;\n\nconst ButtonHeader = styled.header`\n  height: ${SPACE_800}px;\n  display: flex;\n  justify-content: space-between;\n`;\n\nexport const Header = memo(({ isDeleting, handleDeleteToggle }) => (\n  <ButtonHeader>\n    <Button hex={GRAY_300} as=\"a\" href=\"https://github.com/devonChurch/avocado\">\n      <FontAwesomeIcon icon={faGithubAlt} size=\"1x\" />\n      <span>Github</span>\n    </Button>\n    <Button hex={GRAY_300} onClick={handleDeleteToggle}>\n      <FontAwesomeIcon icon={isDeleting ? faTasks : faTrashAlt} size=\"1x\" />\n      <span>{isDeleting ? \"Edit\" : \"Delete\"}</span>\n    </Button>\n  </ButtonHeader>\n));\n","import React, { useEffect } from \"react\";\nimport { LoadControl } from \"./LoadControl\";\n\nexport const Scroll = () => {\n  useEffect(() => {\n    let offset;\n    let throttleId;\n    const createThrottle = action => (throttleId = window.requestAnimationFrame(action));\n    const removeThrottle = () => (throttleId = window.cancelAnimationFrame(throttleId));\n    const checkIsThrottling = () => Boolean(throttleId);\n\n    const setScroll = () => {\n      const { innerHeight, scrollY } = window;\n      const nextScroll = scrollY + offset;\n      const isTooHigh = nextScroll < 0;\n      const isTooLow = nextScroll > document.body.clientHeight - innerHeight;\n      const shouldScroll = !isTooHigh && !isTooLow;\n\n      if (shouldScroll) {\n        window.scroll(0, nextScroll);\n        createThrottle(setScroll);\n      } else {\n        removeThrottle();\n      }\n    };\n\n    const checkScenario = event => {\n      const viewPortHeight = window.innerHeight;\n      const viewPortQuarter = viewPortHeight / 4;\n      const pointerPosition = event.clientY;\n      const isOverTopQuarter = pointerPosition < viewPortQuarter;\n      const isOverBottomQuarter = pointerPosition > viewPortQuarter * 3;\n      const maxScrollOffset = viewPortQuarter;\n      const isThrottling = checkIsThrottling();\n      const shouldUpdateScroll = !isThrottling && (isOverTopQuarter || isOverBottomQuarter);\n      const shouldStopScroll = isThrottling && !(isOverTopQuarter || isOverBottomQuarter);\n\n      if (isOverTopQuarter) {\n        const percentageOffset = (viewPortQuarter - pointerPosition) / viewPortQuarter;\n        const pixelOffset = maxScrollOffset * percentageOffset;\n        offset = -pixelOffset;\n      }\n\n      if (isOverBottomQuarter) {\n        const percentageOffset = (pointerPosition - viewPortQuarter * 3) / viewPortQuarter;\n        const pixelOffset = maxScrollOffset * percentageOffset;\n        offset = pixelOffset;\n      }\n\n      if (shouldUpdateScroll) {\n        createThrottle(setScroll);\n      }\n\n      if (shouldStopScroll) {\n        removeThrottle();\n      }\n    };\n\n    const [createDragLoadControl, cleanUpDragLoadControl] = LoadControl(checkScenario);\n    const dragLoadControl = createDragLoadControl();\n    window.addEventListener(\"dragover\", dragLoadControl);\n\n    return function cleanUp() {\n      removeThrottle();\n      cleanUpDragLoadControl();\n      window.removeEventListener(\"dragover\", dragLoadControl);\n    };\n  }, []);\n\n  return null;\n};\n","import \"normalize.css\";\nimport \"drag-drop-touch\";\nimport React, { useCallback, useMemo, useRef, useState, useEffect } from \"react\";\nimport { TransitionGroup, CSSTransition } from \"react-transition-group\";\nimport nanoid from \"nanoid\";\nimport { createGlobalStyle } from \"styled-components\";\nimport { useLoadControl } from \"./LoadControl\";\nimport { Swatches, UserSwatch, AppendSwatch } from \"./Swatch\";\nimport { Compositions, UserComposition, AppendComposition } from \"./Composition\";\nimport { Header } from \"./Header\";\nimport { Scroll } from \"./Scroll\";\nimport {\n  SWATCH_WIDTH,\n  BLACK,\n  SPACE_500,\n  SPACE_600,\n  SPACE_800,\n  SPEED_500,\n  SPEED_700,\n  VIEWPORT_500,\n  WHITE,\n  findColorComplementFromSwatches,\n  createSwatch,\n  convertStateToQuery,\n  convertStateFromQuery\n} from \"./utils\";\n\nconst GlobalStyle = createGlobalStyle`\n  html {\n    box-sizing: border-box;\n  }\n  \n  *, *:before, *:after {\n    box-sizing: inherit;\n  }\n\n  body {\n    padding: ${SPACE_500}px;\n\n    @media screen and (min-width: ${VIEWPORT_500}px) {\n      padding: ${SPACE_800}px;\n    }\n  }\n\n  #root {\n    display: grid;\n    grid-gap: ${SPACE_500}px;\n\n    @media screen and (min-width: ${VIEWPORT_500}px) {\n      grid-gap: ${SPACE_600}px;\n    }\n  }\n`;\n\nconst createSwatchKey = () => nanoid();\nconst createCompositionKey = createSwatchKey;\n\nconst createIndexComparison = idOne => ([idTwo]) => idOne === idTwo;\nconst findSwatchIndexFromId = (swatches, id) => swatches.findIndex(createIndexComparison(id));\nconst findCompositionIndexFromId = (compositions, id) =>\n  compositions.findIndex(createIndexComparison(id));\n\nconst createReorderTransform = (x = 0, y = 0) => `transform: translate(${x}%, ${y}%);`;\n\n/**\n * Returns a thunk that can calculate the CSS transformation that reorders swatches\n * that the user drags over based not he origin of the dragged swatch.\n */\nconst calculateReorderTransform = (swatches, dragStartId, dragOverId, swatchIndex) => {\n  /** Only calculate if we have the relevant information. */\n  const isInDragOverState = dragStartId && dragOverId && dragStartId !== dragOverId;\n  if (!isInDragOverState) return createReorderTransform;\n\n  /** Only calculate if the current swatch is not the originating dragging swatch. */\n  const dragStartIndex = findSwatchIndexFromId(swatches, dragStartId);\n  const dragOverIndex = findSwatchIndexFromId(swatches, dragOverId);\n  const shouldReorder = dragStartIndex !== swatchIndex;\n  if (!shouldReorder) return createReorderTransform;\n\n  /**\n   * Only calculate is the current swatch falls between the originating dragged\n   * swatch and the dragged over swatch. All outside swatches remain static.\n   */\n  const isBeforeDragSwatches = swatchIndex >= dragStartIndex || swatchIndex >= dragOverIndex;\n  const isAfterDragSwatches = swatchIndex <= dragStartIndex || swatchIndex <= dragOverIndex;\n  const isBetweenDragSwatches = isBeforeDragSwatches && isAfterDragSwatches;\n  if (!isBetweenDragSwatches) return createReorderTransform;\n\n  /**\n   * Based on the direction (\"left\" or \"right\") that the user is dragging we\n   * reorder the swatches that fall between the dragging indexes to fill the gap\n   * left from the originating dragged swatch.\n   */\n  return function positionReorderTransform(prevNode) {\n    const isDraggedRight = dragStartIndex > swatchIndex;\n    const siblingTarget = isDraggedRight ? \"nextElementSibling\" : \"previousElementSibling\";\n    const nextNode = prevNode[siblingTarget];\n    const { offsetTop: prevY, offsetLeft: prevX } = prevNode;\n    const { offsetTop: nextY, offsetLeft: nextX } = nextNode;\n    const dragX = ((nextX - prevX) / SWATCH_WIDTH) * 100;\n    const dragY = ((nextY - prevY) / SWATCH_WIDTH) * 100;\n\n    return createReorderTransform(dragX, dragY);\n  };\n};\n\nconst App = () => {\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** SWATCHES:   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n\n  const [swatches, setSwatches] = useState(new Map([]));\n  // We enrich the \"vanilla\" useState hook with a custom implementation that\n  // throttles and debounces the update of the \"swatches\" references. The swatch\n  // state is the catalyst for performant heavy re-renders (think hundreds of hex\n  // updates as you drag the native color slider). In that regard, we throttle\n  // the amount that the swatches state can be updated.\n  const setLoadControledSwatches = useLoadControl(setSwatches);\n\n  const [dragStartId, setDragStartId] = useState(null);\n  const [dragOverId, setDragOverId] = useState(null);\n  const isUserDragging = !!dragStartId;\n  const dragHex = isUserDragging && swatches.get(dragStartId);\n\n  const removeDragStartId = () => setDragStartId(null);\n  const removeDragOverId = useCallback(() => setDragOverId(null), []);\n  const removeDragIds = useCallback(() => {\n    removeDragStartId(null);\n    removeDragOverId(null);\n  }, [removeDragOverId]);\n\n  const appendSwatch = hex =>\n    setLoadControledSwatches(swatches => new Map([...swatches, [createSwatchKey(), hex]]));\n\n  const appendLastListedSwatch = () => {\n    const [, lastHex] = [...swatches].pop() || [];\n    appendSwatch(lastHex || BLACK);\n  };\n\n  const appendDraggedSwatch = () => {\n    appendSwatch(dragHex);\n    removeDragIds();\n  };\n\n  const updateUserSwatch = useCallback(\n    (id, hex) => setLoadControledSwatches(swatches => new Map([...swatches, [id, hex]])),\n    [swatches]\n  );\n\n  const moveSwatchToNewLocation = useCallback(\n    dropId => {\n      if (dragStartId === dropId) return;\n\n      const prevSwatches = [...swatches];\n      const dropIndex = findSwatchIndexFromId(prevSwatches, dropId);\n      const dragStartIndex = findSwatchIndexFromId(prevSwatches, dragStartId);\n      const shoudPrepend = dropIndex < dragStartIndex;\n      const dropSwatch = [dragStartId, swatches.get(dragStartId)];\n      const nextSwatches = new Map(\n        prevSwatches.reduce((acc, [id, hex]) => {\n          switch (true) {\n            case id === dragStartId:\n              return acc; // Remove the swatch from its orignal location.\n            case id === dropId:\n              return shoudPrepend\n                ? [...acc, dropSwatch, [id, hex]]\n                : [...acc, [id, hex], dropSwatch];\n            default:\n              return [...acc, [id, hex]];\n          }\n        }, [])\n      );\n      setLoadControledSwatches(nextSwatches);\n      removeDragIds();\n    },\n    [swatches, dragStartId, removeDragIds]\n  );\n\n  const createReorderTransformHandler = (...args) =>\n    calculateReorderTransform([...swatches], ...args);\n\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** COMPOSITIONS:  ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n  const [compositions, setCompositions] = useState([]);\n\n  const [activeCompositionId, setActiveCompositionId] = useState(null);\n  const removeActiveCompositionId = () => setActiveCompositionId(null);\n\n  const setSwatchAppearanceAgainstCompositionTarget = swatchId => {\n    if (!activeCompositionId) return;\n    const composition = compositions.get(activeCompositionId);\n    const hasBase = composition.baseId === swatchId;\n    const hasContent = composition.contentId === swatchId;\n    const shouldSwatchPronounce = hasBase || hasContent;\n    const shouldSwatchRegress = !shouldSwatchPronounce && activeCompositionId;\n\n    return { shouldSwatchPronounce, shouldSwatchRegress };\n  };\n\n  const appendComposition = ({ baseId, contentId } = {}) => {\n    const compositionIds = {\n      baseId: baseId || findColorComplementFromSwatches(contentId, swatches),\n      contentId: contentId || findColorComplementFromSwatches(baseId, swatches)\n    };\n    setCompositions(new Map([...compositions, [createCompositionKey(), compositionIds]]));\n  };\n\n  const appendLastListedComposition = () => {\n    const [, compositionIds] = [...compositions].pop() || [];\n    appendComposition(compositionIds);\n  };\n\n  const appendCompositionFromDraggedSwatch = compositionIds => {\n    appendComposition(compositionIds);\n    removeDragIds();\n  };\n\n  const updateComposition = useCallback(\n    (compId, composition) => {\n      const prevComps = [...compositions];\n      const compIndex = findCompositionIndexFromId(prevComps, compId);\n      const nextComps = [\n        ...prevComps.slice(0, compIndex),\n        [compId, composition],\n        ...prevComps.slice(compIndex + 1)\n      ];\n      setCompositions(new Map(nextComps));\n    },\n    [compositions]\n  );\n\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** QUERY STRING:  ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n\n  useEffect(() => {\n    const { swatches, compositions } = convertStateFromQuery(window.location.search);\n\n    setLoadControledSwatches(swatches);\n    setCompositions(compositions);\n  }, []);\n\n  useEffect(() => {\n    const search = convertStateToQuery(swatches, compositions);\n    const { protocol, host, pathname } = window.location;\n    const url = `${protocol}//${host}${pathname}${search}`;\n\n    window.history.replaceState({}, \"\", url);\n  }, [swatches, compositions]);\n\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** DELETE:  ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n\n  const [isDeleting, setIsDeleting] = useState(false);\n  const handleDeleteToggle = () => setIsDeleting(!isDeleting);\n\n  const deleteSwatch = useCallback(\n    swatchId => {\n      const prevSwatches = [...swatches];\n      const swatchIndex = findSwatchIndexFromId(prevSwatches, swatchId);\n      const nextSwatches = [\n        ...prevSwatches.slice(0, swatchIndex),\n        ...prevSwatches.slice(swatchIndex + 1)\n      ];\n      setLoadControledSwatches(new Map(nextSwatches));\n    },\n    [swatches]\n  );\n\n  const deleteComposition = useCallback(\n    compId => {\n      const prevComps = [...compositions];\n      const compIndex = findCompositionIndexFromId(prevComps, compId);\n      const nextComps = [...prevComps.slice(0, compIndex), ...prevComps.slice(compIndex + 1)];\n      setCompositions(new Map(nextComps));\n    },\n    [compositions]\n  );\n\n  const hasEnoughSwatchesToDelete = swatches.size > 2;\n  const hasEnoughCompositionsToDelete = compositions.size > 1;\n\n  const checkIsSwatchInAnyComposition = (() => {\n    const activeSwatchIds = [...compositions.values()].reduce(\n      (acc, { baseId, contentId }) => [...acc, baseId, contentId],\n      []\n    );\n\n    return swatchId => activeSwatchIds.includes(swatchId);\n  })();\n\n  return (\n    <>\n      <GlobalStyle />\n      <Header {...{ isDeleting, handleDeleteToggle }} />\n      {isUserDragging && <Scroll />}\n      <TransitionGroup component={Swatches}>\n        {[...swatches].map(([swatchId, hex], swatchIndex) => (\n          <CSSTransition key={swatchId} timeout={SPEED_700} classNames=\"swatch\">\n            <UserSwatch\n              key={swatchId}\n              {...{\n                swatchId,\n                hex,\n                isUserDragging,\n                isDeleting,\n                ...setSwatchAppearanceAgainstCompositionTarget(swatchId)\n              }}\n              hasCapacityToDelete={\n                hasEnoughSwatchesToDelete && !checkIsSwatchInAnyComposition(swatchId)\n              }\n              handleChange={updateUserSwatch}\n              handleDragStart={setDragStartId}\n              handleDragOver={setDragOverId}\n              handleDragExit={removeDragOverId}\n              handleDragEnd={removeDragIds}\n              handleDrop={moveSwatchToNewLocation}\n              handleDelete={deleteSwatch}\n              createReorderTransform={createReorderTransformHandler(\n                dragStartId,\n                dragOverId,\n                swatchIndex\n              )}\n            />\n          </CSSTransition>\n        ))}\n        <>\n          {/**\n           * Use a <Fragment /> to protect the \"append\" <CSSTransitions /> from\n           * absorbing the parent <TransitionGroup />.\n           */\n          isDeleting ? (\n            /**\n             * Add in a placeholder so that the missing space does NOT cause\n             * aggressive reflow.\n             */\n            <div />\n          ) : (\n            <CSSTransition unmountOnExit in={!isDeleting} timeout={SPEED_700} classNames=\"addItem\">\n              <AppendSwatch\n                {...{ dragHex }}\n                handleClick={appendLastListedSwatch}\n                handleDrop={appendDraggedSwatch}\n              />\n            </CSSTransition>\n          )}\n        </>\n      </TransitionGroup>\n      <TransitionGroup component={Compositions}>\n        {[...compositions].map(([compId, { baseId, contentId }]) => (\n          <CSSTransition key={compId} timeout={SPEED_700} classNames=\"composition\">\n            <UserComposition\n              key={compId}\n              {...{\n                compId,\n                baseId,\n                contentId,\n                dragStartId,\n                dragHex,\n                isUserDragging,\n                isDeleting,\n                setActiveCompositionId,\n                removeActiveCompositionId\n              }}\n              hasCapacityToDelete={hasEnoughCompositionsToDelete}\n              baseHex={swatches.get(baseId)}\n              contentHex={swatches.get(contentId)}\n              handleDrop={updateComposition}\n              handleDelete={deleteComposition}\n            />\n          </CSSTransition>\n        ))}\n        <>\n          {isDeleting ? (\n            <div />\n          ) : (\n            <CSSTransition unmountOnExit in={!isDeleting} timeout={SPEED_700} classNames=\"addItem\">\n              <AppendComposition\n                {...{ dragStartId, dragHex, isUserDragging }}\n                handleClick={appendLastListedComposition}\n                handleDrop={appendCompositionFromDraggedSwatch}\n              />\n            </CSSTransition>\n          )}\n        </>\n      </TransitionGroup>\n    </>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n// import * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}