{"version":3,"sources":["utils.js","Swatch.js","Composition.js","Header.js","Scroll.js","App.js","index.js"],"names":["createSwatch","hex","tinyColor","FOCUS_SHADOW_500","setAlpha","LUMINANCE_SHADOW_500","findColorComplementFromSwatches","compareId","swatches","compareHex","get","hexes","values","complementHex","mostReadable","toHexString","entries","find","checkHasLowLuminance","getLuminance","updateLuminanceStatic","lighten","darken","isLuminant","luminance","createColorCompanion","createUpdate","alpha","prevSwatch","toHsl","luminanceBefore","l","nextSwatch","toString","createOffsetColor","createFocusColor","createActiveColor","createFocusborder","createFocusStateWithShadow","resetList","css","positionAbsolute","defaultSwatches","Map","defaultCompositions","baseId","contentId","deleteAnimation","offset","keyframes","deleteKeyframes","SwatchList","styled","ul","UserItem","div","isUserDragging","isDragged","isAboutToDrag","shouldSwatchRegress","isDeleting","styles","createFocusState","swatchActiveState","DragHitBox","shouldSwatchPronounce","hasCapacityToDelete","ReorderTransformation","reorderTransform","AddItem","li","AddButton","button","isTargeted","createTargetColor","Input","input","DeleteButton","Swatches","UserSwatch","memo","swatchId","handleChange","handleDragStart","handleDragOver","handleDragExit","handleDragEnd","handleDrop","handleDelete","createReorderTransform","useState","setIsDragged","setIsAboutToDrag","inputValue","setInputValue","debouncedInputHandler","debounce","value","swatchRef","useRef","draggable","ref","onDragStart","event","dataTransfer","setData","setDragImage","current","SWATCH_WIDTH","onDragEnd","onDragOver","preventDefault","onDragLeave","onDrop","onPointerDown","undefined","onPointerUp","onClick","querySelector","focus","CSSTransition","unmountOnExit","in","timeout","classNames","icon","faTimes","size","type","onChange","target","AppendSwatch","dragHex","handleClick","setIsTargeted","onPointerEnter","onPointerLeave","faPlus","CompList","SPACE_500","IconList","DividerList","ResultList","Character","span","children","Examples","baseHex","contentHex","SmallText","isBold","Divider","height","Compositions","findAccessibilityLevel","comparison","level","isReadable","createAccessibilityComparison","Icons","faCheckCircle","faCalendarAlt","faCommentDots","faStar","faTrashAlt","map","index","key","Dividers","Level","characters","split","char","DropAreas","ResultIcon","FontAwesomeIcon","Results","includes","faCheck","percentage","readability","Math","round","createContrastPercentage","ItemWrapper","AddCompositionButton","isActive","AddSlotButton","UserComposition","compId","dragStartId","setActiveCompositionId","removeActiveCompositionId","isContentTargeted","setIsContentTargeted","isBaseTargeted","setIsBaseTargeted","AppendComposition","isAddTargeted","setIsAddTargeted","Button","ButtonHeader","header","Header","handleDeleteToggle","as","href","faGithubAlt","faTasks","Scroll","throttledScroll","useEffect","setScroll","window","innerHeight","nextScroll","scrollY","isTooHigh","isTooLow","document","body","clientHeight","scroll","requestAnimationFrame","handlePointerMove","viewPortQuarter","pointerPosition","clientY","isOverTopQuarter","isOverBottomQuarter","maxScrollOffset","shouldUpdateScroll","shouldStopScroll","pixelOffset","checkScenario","throttledDrag","throttle","trailing","addEventListener","removeEventListener","GlobalStyle","createGlobalStyle","createSwatchKey","nanoid","createCompositionKey","createIndexComparison","idOne","idTwo","findSwatchIndexFromId","id","findIndex","findCompositionIndexFromId","compositions","x","y","calculateReorderTransform","dragOverId","swatchIndex","dragStartIndex","dragOverIndex","prevNode","nextNode","prevY","offsetTop","prevX","offsetLeft","nextY","nextX","App","initialState","delay","isPrepped","setIsPrepped","state","setState","throttled","newState","cancel","useThrottledState","setSwatches","setDragStartId","setDragOverId","removeDragOverId","useCallback","removeDragIds","appendSwatch","updateUserSwatch","moveSwatchToNewLocation","dropId","prevSwatches","shoudPrepend","dropSwatch","nextSwatches","reduce","acc","createReorderTransformHandler","args","setCompositions","activeCompositionId","appendComposition","compositionIds","updateComposition","composition","prevComps","compIndex","nextComps","slice","search","qs","parse","ignoreQueryPrefix","s","c","swatchMap","compMap","hasUserConfig","convertStateFromQuery","location","swatchFlat","swatchKeys","keys","compFlat","indexOf","stringify","addQueryPrefix","convertStateToQuery","protocol","host","pathname","url","history","replaceState","setIsDeleting","deleteSwatch","deleteComposition","hasEnoughSwatchesToDelete","hasEnoughCompositionsToDelete","checkIsSwatchInAnyComposition","activeSwatchIds","TransitionGroup","component","hasBase","hasContent","setSwatchAppearanceAgainstCompositionTarget","pop","lastHex","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.8df23f1b.chunk.js","sourcesContent":["import { css, keyframes } from \"styled-components\";\nimport tinyColor from \"tinycolor2\";\nimport qs from \"qs\";\n\nexport const createSwatch = hex => tinyColor(hex);\n\nexport const SPACE_300 = 4;\nexport const SPACE_400 = 8;\nexport const SPACE_500 = 16;\nexport const SPACE_600 = 24;\nexport const SPACE_700 = 32;\nexport const SPACE_800 = 40;\n\nexport const SWATCH_WIDTH = 80;\nexport const BORDER_WIDTH = 3;\nexport const FOCUS_WIDTH = 3;\nexport const COMP_WIDTH_LARGE = SPACE_500 * 16;\nexport const COMP_HEIGHT_LARGE = SPACE_500 * 18;\nexport const COMP_WIDTH_SMALL = COMP_WIDTH_LARGE;\nexport const COMP_HEIGHT_SMALL = SPACE_500 * 14;\n\nexport const BORDER_RADIUS = 4;\n\nexport const WHITE = \"#fff\";\nexport const BLACK = \"#000\";\n\nexport const GRAY_100 = \"#EAF0EE\";\nexport const GRAY_300 = \"#c8d5d1\";\nexport const GRAY_500 = \"#8DA79F\";\nexport const GRAY_700 = \"#5c716b\";\nexport const GRAY_900 = \"#40504C\";\n\nexport const SPEED_500 = 250;\nexport const SPEED_700 = 500;\n\nexport const SCALE_200 = 0.5;\nexport const SCALE_300 = 0.8;\nexport const SCALE_400 = 0.9;\nexport const SCALE_500 = 1;\nexport const SCALE_600 = 1.1;\n\nexport const VIEWPORT_500 = 768;\n\nexport const FOCUS_SHADOW_500 = `0 0 13px ${FOCUS_WIDTH}px ${createSwatch(BLACK).setAlpha(0.25)}`;\n\nexport const LUMINANCE_SHADOW_500 = `inset 0 0 0 ${BORDER_WIDTH}px ${createSwatch(BLACK).setAlpha(\n  0.1\n)}`;\n\nexport const findColorComplementFromSwatches = (compareId, swatches) => {\n  const compareHex = swatches.get(compareId);\n  const hexes = [...swatches.values()];\n  const complementHex = tinyColor.mostReadable(compareHex, hexes).toHexString();\n  const [complementId] = [...swatches.entries()].find(([, hex]) => hex === complementHex);\n\n  return complementId;\n};\n\nexport const checkHasLowLuminance = hex => createSwatch(hex).getLuminance() > 0.9;\n\nconst updateLuminanceStatic = (lighten, darken) => (isLuminant, luminance) =>\n  isLuminant ? lighten : darken;\n\nconst updateLuminanceDynamic = percentage => (isLuminant, luminance) => {\n  const offset = (luminance * percentage) / 100;\n  return isLuminant ? Math.max(luminance - offset, 0) : Math.min(luminance + offset, 100);\n};\n\nconst createColorCompanion = (createUpdate, alpha = 1) => hex => {\n  const prevSwatch = createSwatch(hex).toHsl();\n  const { l: luminanceBefore } = prevSwatch;\n  const isLuminant = luminanceBefore > 0.6;\n  const luminanceAfter = createUpdate(isLuminant, luminanceBefore);\n  const nextSwatch = { ...prevSwatch, l: luminanceAfter };\n\n  return tinyColor(nextSwatch)\n    .setAlpha(alpha)\n    .toString();\n};\n\nexport const createOffsetColor = createColorCompanion(updateLuminanceStatic(0.2, 0.8));\nexport const createTargetColor = hex => hex;\nexport const createFocusColor = createColorCompanion(updateLuminanceStatic(0.3, 0.7), 0.5);\nexport const createActiveColor = createColorCompanion(updateLuminanceStatic(0.5, 0.5), 1);\n\nexport const createFocusborder = hex => `0 0 0 ${FOCUS_WIDTH}px ${createFocusColor(hex)}`;\nexport const createFocusState = hex => createFocusborder(hex);\nexport const createFocusStateWithShadow = hex => `${FOCUS_SHADOW_500}, ${createFocusborder(hex)}`;\n\nexport const resetList = css`\n  list-style: none;\n  margin: 0;\n  padding: 0;\n`;\n\nexport const positionAbsolute = css`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n`;\n\nconst defaultSwatches = new Map([\n  [\"1\", createSwatch(\"rgb(88, 213, 255)\").toHexString()],\n  [\"2\", createSwatch(\"rgb(246, 199, 163)\").toHexString()],\n  [\"3\", createSwatch(\"rgb(240, 124, 125)\").toHexString()],\n  [\"4\", createSwatch(\"rgb(218, 68, 93)\").toHexString()],\n  [\"5\", createSwatch(\"rgb(38, 51, 56)\").toHexString()]\n]);\n\nconst defaultCompositions = new Map([\n  [\"1\", { baseId: \"5\", contentId: \"1\" }],\n  [\"2\", { baseId: \"4\", contentId: \"2\" }],\n  [\"3\", { baseId: \"2\", contentId: \"5\" }]\n]);\n\nexport const convertStateToQuery = (swatches, compositions) => {\n  const swatchFlat = [...swatches.values()];\n  const swatchKeys = [...swatches.keys()];\n  const compFlat = [...compositions.values()].map(({ baseId, contentId }) => [\n    swatchKeys.indexOf(baseId),\n    swatchKeys.indexOf(contentId)\n  ]);\n\n  return qs.stringify({ s: swatchFlat, c: compFlat }, { addQueryPrefix: true });\n};\n\nexport const convertStateFromQuery = search => {\n  const { s: swatches = [], c: compositions = [] } = qs.parse(search, { ignoreQueryPrefix: true });\n  const swatchMap = new Map(swatches.map((value, index) => [`${index}`, value]));\n  const compMap = new Map(\n    compositions.map(([baseId, contentId], index) => [`${index}`, { baseId, contentId }])\n  );\n  const hasUserConfig = swatchMap.size || compMap.size;\n\n  return {\n    swatches: hasUserConfig ? swatchMap || [] : defaultSwatches,\n    compositions: hasUserConfig ? compMap || [] : defaultCompositions\n  };\n};\n\nexport const deleteKeyframes = offset => keyframes`\n  from {\n    transform: rotate(-${offset}deg);\n  }\n\n  to {\n    transform: rotate(${offset}deg);\n  }\n`;\n\nexport const deleteAnimation = offset => css`\n  transform-origin: right top;\n  animation: 0.1s infinite alternate ${deleteKeyframes(offset)};\n  animation-timing-function: ease-in-out;\n`;\n","import React, { memo, useState, useEffect, useRef, useCallback } from \"react\";\nimport { CSSTransition } from \"react-transition-group\";\nimport styled, { css } from \"styled-components\";\nimport debounce from \"lodash.debounce\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faPlus, faTimes } from \"@fortawesome/free-solid-svg-icons\";\nimport {\n  SWATCH_WIDTH,\n  BORDER_WIDTH,\n  BORDER_RADIUS,\n  WHITE,\n  BLACK,\n  GRAY_300,\n  GRAY_500,\n  GRAY_900,\n  SPEED_500,\n  SPEED_700,\n  SCALE_300,\n  SCALE_400,\n  SCALE_500,\n  SCALE_600,\n  SPACE_300,\n  SPACE_400,\n  SPACE_500,\n  SPACE_600,\n  SPACE_700,\n  LUMINANCE_SHADOW_500,\n  createSwatch,\n  createOffsetColor,\n  createTargetColor,\n  createFocusState,\n  createActiveColor,\n  createFocusStateWithShadow,\n  checkHasLowLuminance,\n  resetList,\n  positionAbsolute,\n  deleteAnimation\n} from \"./utils\";\n\nconst SwatchList = styled.ul`\n  ${resetList}\n  display: grid;\n  grid-gap: 0;\n  grid-template-rows: repeat(auto-fill, ${SWATCH_WIDTH}px);\n  grid-template-columns: repeat(auto-fill, ${SWATCH_WIDTH}px);\n\n  /** Regardless of content we ALWAYS conform to the rigid grid system dimensions. */\n  > * {\n    height: ${SWATCH_WIDTH}px;\n    width: ${SWATCH_WIDTH}px;\n  }\n`;\n\nconst UserItem = styled.div`\n  ${positionAbsolute}\n  background: ${({ hex }) => hex};\n  /* pointer-events: none; */\n  transition-duration: ${SPEED_700}ms, ${SPEED_500}ms, ${SPEED_700}ms, ${SPEED_700}ms;\n  transition-property: background, box-shadow, transform, border;\n\n  ${({ hex, isUserDragging, isDragged, isAboutToDrag, shouldSwatchRegress, isDeleting }) => {\n    let styles = \"\";\n\n    /**\n     * If a swatch color the user has selected has VERY LOW luminance (white or\n     * close to white) then the swatch will blend into the application background\n     * (and effectively dissapear).\n     *\n     * In that regard, we add a slightly darker border around the color to\n     * differentiate it from the background (if it needs it).\n     */\n    if (checkHasLowLuminance(hex)) {\n      styles += `\n        &:after {\n          ${positionAbsolute}\n          border-radius: 4px;\n          box-shadow: ${LUMINANCE_SHADOW_500};\n          content: \"\";\n          display: block;\n          transition: opacity ${SPEED_500}ms;\n        }\n      `;\n    }\n\n    if (isDragged || isUserDragging || isAboutToDrag || shouldSwatchRegress || isDeleting) {\n      styles += `\n        border-radius: ${BORDER_RADIUS}px;\n      `;\n    }\n\n    if (isUserDragging || isDeleting) {\n      styles += `\n        transform: scale(${SCALE_300});\n      `;\n    }\n\n    /**\n     * We want the original location where the swatch was dragged from to be an\n     * \"empty\" slot (by default it just sits there).\n     *\n     * + If we change `opacity: 0;` then that ALSO changes the dragged item\n     *   attached to the users mouse position.\n     *\n     * + Changing `background: white;` ONLY changes the placeholder \"dormant\"\n     *   swatch =)\n     */\n    if (isDragged && isUserDragging) {\n      styles += `\n        background: ${WHITE};\n      `;\n    }\n\n    /**\n     * The browser will take a \"snapshot\" or the dragged swatch IMMEDIATELY after\n     * dragging starts. The \"snapshot\" is a square around the DOM element and\n     * crops out anything NOT in that box (like `outline` and `box-shadow`). In\n     * that regard we need to have the dragging swatch BEFORE dragging starts.\n     *\n     * To do this we remove and `transition-duration` (so that things happen\n     * immediately - getting caught half way through a transition looks disjointed)\n     * and change the following:\n     *\n     * + `scale` shrink the main item (including `:focus` `box-shadow`) INSIDE\n     *   the crop box. This actually look pretty good as it simulates an \"on press\"\n     *   aesthetic.\n     *\n     * + Remove the drop shadow as it bleeds off the swatch crop area and can be\n     *   seen in the swatch rounded corners.\n     */\n    if (isAboutToDrag) {\n      styles += `\n        box-shadow: ${({ hex }) => createFocusState(hex)} !important;\n        transition-duration: 0ms;\n        transform: scale(${SCALE_400});\n      `;\n    }\n\n    return css`\n      ${styles}\n    `;\n  }}\n`;\n\nconst swatchActiveState = css`\n  z-index: 10;\n\n  ${UserItem} {\n    box-shadow: ${({ hex }) => createFocusStateWithShadow(hex)};\n    border-radius: ${BORDER_RADIUS}px;\n    outline: 0;\n\n    &:after {\n      opacity: 0;\n    }\n  }\n`;\n\nconst DragHitBox = styled.div`\n  position: relative;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n  /**\n   * When an item is being dragged we send it to the BACK so that ALL other\n   * swatches can overlap when the \"recording\" animation is running. The dragging\n   * swatch is also completely white and therefore CANNOT reside on top of\n   * anything else.\n   */\n  z-index: ${({ isDragged }) => (isDragged ? \"0\" : \"1\")};\n\n  ${({ isUserDragging, isDeleting }) =>\n    !isUserDragging &&\n    !isDeleting &&\n    /**\n     * Do NOT show these interaction states on ANY swatches when the user is\n     * dragging as swatches will all be changing their `:hover` states on/off\n     * throughout the dragging process.\n     */\n    css`\n      &:focus-within,\n      &:hover {\n        ${swatchActiveState}\n      }\n    `}\n\n  ${({ shouldSwatchRegress }) =>\n    shouldSwatchRegress &&\n    css`\n      opacity: 0.25;\n      transform: scale(${SCALE_300});\n    `}\n\n  ${({ shouldSwatchPronounce }) => shouldSwatchPronounce && swatchActiveState}\n\n  ${({ isDeleting, hasCapacityToDelete }) =>\n    isDeleting && hasCapacityToDelete && deleteAnimation(2)}\n\n  /** React CSSTransition animation property when an item is in its DORMANT state. */\n  &.swatch-enter,\n  &.swatch-exit,\n  &.swatch-exit-active {\n    opacity: 0;\n    transform: scale(0);\n  }\n\n  /** React CSSTransition animation property when an item is in its ACTIVE state. */\n  &.swatch-enter-active,\n  &.swatch-enter-done {\n    opacity: 1;\n    transform: scale(${SCALE_500});\n  }\n`;\n\nconst ReorderTransformation = styled.div`\n  ${positionAbsolute}\n  transition: ${SPEED_500}ms;\n\n  ${({ reorderTransform }) =>\n    css`\n      ${reorderTransform}\n    `}\n\n  ${({ isUserDragging }) => {\n    /*\n     * When a users is dragging a `<Swatch />` we want the \"re-order\" animation\n     * (simulated via CSS `transform`'s) to run.\n     *\n     * When however, the user drops a `<Swatch />` we want the items to \"re-order\"\n     * in the DOM (hard-coded NOT simulated). In that regard, if we are still\n     * running `transition`s on the now redundant `transform`'s then we get a\n     * flicker as the `<Swatch />` move back to their dormant state. When we apply\n     * NO `transition` the drop effect feel \"solid\".\n     */\n    switch (isUserDragging) {\n      case true:\n        return css`\n          transition-property: transform;\n        `;\n      default:\n        return css`\n          transition-property: none;\n        `;\n    }\n  }}\n`;\n\nexport const AddItem = styled.li`\n  /** Force contents to take up ALL of the \"cells\" x/y space. */\n  display: grid;\n  padding: ${SPACE_400}px;\n  position: relative;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n\n  /** React CSSTransition animation property when the add <button /> is in NOT ACTIVE. */\n  &.addItem-enter,\n  &.addItem-exit {\n    opacity: 0;\n    transform: scale(${SCALE_300});\n  }\n\n  /** React CSSTransition animation property when the add <button /> is in IS ACTIVE. */\n  &.addItem-enter-active {\n    opacity: 1;\n    transform: scale(${SCALE_500});\n  }\n`;\n\nexport const AddButton = styled.button`\n  align-self: stretch;\n  appearance: none;\n  border: ${BORDER_WIDTH}px solid ${({ hex }) => createOffsetColor(hex)};\n  border-radius: ${BORDER_RADIUS}px;\n  color: ${({ hex }) => createOffsetColor(hex)};\n  cursor: pointer;\n  display: block;\n  font-family: sans-serif;\n  font-weight: bold;\n  font-size: 14px;\n  height: 100%;\n  justify-self: stretch;\n  text-transform: uppercase;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: box-shadow, background, opacity, transform, width, height;\n  width: 100%;\n  outline: 0;\n\n  ${({ isTargeted }) =>\n    isTargeted\n      ? css`\n          background: ${({ hex }) => createTargetColor(hex)};\n          /* transform: scale(${SCALE_600}); */\n          transform: translate(-${SPACE_300}px, -${SPACE_300}px);\n          width: calc(100% + ${SPACE_400}px);\n          height: calc(100% + ${SPACE_400}px);\n        `\n      : css`\n          background: ${({ hex }) => hex};\n          /* transform: scale(${SCALE_300}); */\n        `};\n\n  &:focus,\n  &:hover {\n    box-shadow: ${({ hex }) => createFocusStateWithShadow(hex)};\n  }\n\n  &:active {\n    background: ${({ hex }) => createActiveColor(hex)};\n  }\n`;\n\nconst Input = styled.input`\n  ${positionAbsolute}\n  appearance: none;\n  opacity: 0;\n`;\n\nexport const DeleteButton = styled(AddButton)`\n  align-items: center;\n  display: flex;\n  height: ${SPACE_700}px;\n  justify-content: center;\n  position: absolute;\n  right: 0;\n  top: 0;\n  width: ${SPACE_700}px;\n  max-width: ${SPACE_700}px;\n\n  /** React CSSTransition animation property when the add <button /> is in NOT ACTIVE. */\n  &.deleteItem-enter,\n  &.deleteItem-exit {\n    opacity: 0;\n    transform: translate(${SPACE_500}px, -${SPACE_500}px) scale(${SCALE_300});\n  }\n\n  /** React CSSTransition animation property when the add <button /> is in IS ACTIVE. */\n  &.deleteItem-enter-active,\n  &.deleteItem-enter-done {\n    opacity: 1;\n    transform: translate(${SPACE_500}px, -${SPACE_500}px) scale(${SCALE_500});\n  }\n`;\n\nexport const Swatches = SwatchList;\n\nexport const UserSwatch = memo(\n  ({\n    swatchId,\n    hex,\n    handleChange,\n    handleDragStart,\n    handleDragOver,\n    handleDragExit,\n    handleDragEnd,\n    handleDrop,\n    isUserDragging,\n    isDeleting,\n    handleDelete,\n    hasCapacityToDelete,\n    createReorderTransform,\n    shouldSwatchPronounce,\n    shouldSwatchRegress\n  }) => {\n    const [isDragged, setIsDragged] = useState(false);\n    const [isAboutToDrag, setIsAboutToDrag] = useState(false);\n\n    /**\n     * We are debouncing the color input change to our `swatch` global state.\n     * Debouncing causes the swatch hex to hang on the current value until the\n     * callback finally updates. This \"hanging\" makes the native color `<input />`\n     * constantly revert back to the swatch hex rather than the users current\n     * selection.\n     *\n     * In that regard, we need to keep a local reference to what the user has\n     * selected as their \"next\" hex choice so that the UI responds with a snappy\n     * experience.\n     */\n    const [inputValue, setInputValue] = useState(hex);\n    const debouncedInputHandler = debounce(value => handleChange(swatchId, value), 100);\n\n    const swatchRef = useRef(null);\n\n    return (\n      <DragHitBox\n        {...{\n          isDragged,\n          isUserDragging,\n          hex,\n          shouldSwatchPronounce,\n          shouldSwatchRegress,\n          isDeleting,\n          hasCapacityToDelete\n        }}\n        draggable={!isDeleting}\n        ref={swatchRef}\n        onDragStart={event => {\n          setIsAboutToDrag(false);\n          /*\n           * Even though we are setting the drag n drop state through React Firefox\n           * will not initialise a DnD scenario without setting the `dataTransfer`.\n           */\n          event.dataTransfer.setData(\"text/plain\", \"banana\");\n\n          /**\n           * Set the drag image that will \"stick\" to the users mouse position during\n           * the entire drag sequence.\n           */\n          const offset = SWATCH_WIDTH / 2;\n          event.dataTransfer.setDragImage(swatchRef.current, offset, offset);\n\n          setIsDragged(true);\n          handleDragStart(swatchId);\n        }}\n        onDragEnd={() => {\n          setIsDragged(false);\n          handleDragEnd();\n        }}\n        onDragOver={event => {\n          handleDragOver(swatchId);\n          /*\n           * MDN suggests applying `preventDefault` on specific DnD event hooks.\n           * @see https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Handle_the_drop_effect\n           */\n          event.preventDefault();\n        }}\n        onDragLeave={handleDragExit}\n        onDrop={event => {\n          setIsDragged(false);\n          handleDrop(swatchId);\n          /*\n           * MDN suggests applying `preventDefault` on specific DnD event hooks.\n           * @see https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Handle_the_drop_effect\n           */\n          event.preventDefault();\n        }}\n        onPointerDown={isDeleting ? undefined : () => setIsAboutToDrag(true)}\n        onPointerUp={isDeleting ? undefined : () => setIsAboutToDrag(false)}\n        onClick={() => {\n          /**\n           * Addresses an iOS issue where the native color input would not trigger\n           * focus when nested inside the drag area (and all of its own touch\n           * listeners). In that regard when the main wrapper is \"clicked\" we give\n           * focus to the nested <input />.\n           */\n          swatchRef.current.querySelector(\"input\").focus();\n        }}\n      >\n        <ReorderTransformation\n          {...{ isDragged, isUserDragging }}\n          reorderTransform={createReorderTransform(swatchRef.current)}\n        >\n          <UserItem\n            {...{\n              hex,\n              isDragged,\n              isUserDragging,\n              isAboutToDrag,\n              shouldSwatchRegress,\n              isDeleting\n            }}\n          >\n            <CSSTransition\n              unmountOnExit\n              in={isDeleting && hasCapacityToDelete}\n              timeout={SPEED_700}\n              classNames=\"deleteItem\"\n            >\n              <DeleteButton hex={GRAY_300} onClick={() => handleDelete(swatchId)}>\n                <FontAwesomeIcon icon={faTimes} size=\"1x\" />\n              </DeleteButton>\n            </CSSTransition>\n          </UserItem>\n          {!isDeleting && (\n            <Input\n              type=\"color\"\n              value={inputValue}\n              onChange={event => {\n                const { value } = event.target;\n                setInputValue(value);\n                debouncedInputHandler(value);\n              }}\n            />\n          )}\n        </ReorderTransformation>\n      </DragHitBox>\n    );\n  }\n);\n\nexport const AppendSwatch = memo(({ dragHex, handleClick, handleDrop }) => {\n  const [isTargeted, setIsTargeted] = useState(false);\n\n  return (\n    <AddItem>\n      <AddButton\n        {...{ isTargeted }}\n        hex={isTargeted && dragHex ? dragHex : GRAY_300}\n        onClick={handleClick}\n        onDragOver={event => {\n          /*\n           * An `onDragOver` event MUST be present in order for a `onDrop` to\n           * trigger!\n           */\n          setIsTargeted(true);\n          event.preventDefault();\n        }}\n        onDragLeave={() => setIsTargeted(false)}\n        onPointerEnter={() => setIsTargeted(true)}\n        onPointerLeave={() => setIsTargeted(false)}\n        onDrop={event => {\n          handleDrop();\n          setIsTargeted(false);\n          /*\n           * MDN suggests applying `preventDefault` on specific DnD event hooks.\n           * @see https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Handle_the_drop_effect\n           */\n          event.preventDefault();\n        }}\n      >\n        <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n      </AddButton>\n    </AddItem>\n  );\n});\n","import React, { memo, useEffect, useRef, useState } from \"react\";\nimport { CSSTransition } from \"react-transition-group\";\nimport styled, { css } from \"styled-components\";\nimport tinyColor from \"tinycolor2\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faPlus, faCheck, faTimes } from \"@fortawesome/free-solid-svg-icons\";\nimport {\n  faCheckCircle,\n  faCalendarAlt,\n  faCommentDots,\n  faStar,\n  faTrashAlt\n} from \"@fortawesome/free-regular-svg-icons\";\nimport {\n  BLACK,\n  GRAY_300,\n  GRAY_900,\n  COMP_HEIGHT_LARGE,\n  COMP_WIDTH_LARGE,\n  COMP_HEIGHT_SMALL,\n  COMP_WIDTH_SMALL,\n  BORDER_RADIUS,\n  BORDER_WIDTH,\n  SCALE_200,\n  SCALE_300,\n  SCALE_500,\n  SCALE_600,\n  SPACE_400,\n  SPACE_500,\n  SPACE_600,\n  SPACE_800,\n  SPEED_500,\n  SPEED_700,\n  VIEWPORT_500,\n  LUMINANCE_SHADOW_500,\n  createSwatch,\n  checkHasLowLuminance,\n  resetList,\n  positionAbsolute,\n  deleteAnimation\n} from \"./utils\";\nimport { AppendSwatch, AddItem, AddButton, DeleteButton } from \"./Swatch\";\n\nconst CompList = styled.ul`\n  ${resetList}\n  display: grid;\n  grid-gap: ${SPACE_500}px;\n  grid-template-columns: repeat(auto-fit, minmax(${COMP_WIDTH_LARGE}px, auto));\n  /* grid-template-rows: repeat(auto-fill, minmax(${COMP_HEIGHT_LARGE}px, auto)); */\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    grid-gap: ${SPACE_600}px;\n  }\n\n  > * {\n    min-height: ${COMP_HEIGHT_SMALL}px;\n    min-width: ${COMP_WIDTH_SMALL}px;\n\n    @media screen and (min-width: ${VIEWPORT_500}px) {\n      min-height: ${COMP_HEIGHT_LARGE}px;\n      min-width: ${COMP_WIDTH_LARGE}px;\n    }\n  }\n`;\n\nconst IconList = styled.ul`\n  ${resetList}\n\n  display: grid;\n  grid-template-columns: repeat(auto-fit, 1rem);\n  grid-gap: ${SPACE_500}px;\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    grid-gap: ${SPACE_600}px;\n  }\n`;\n\nconst DividerList = styled.ul`\n  ${resetList}\n  display: grid;\n  grid-gap: ${SPACE_500}px;\n  grid-template-columns: 1fr;\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    grid-gap: ${SPACE_600}px;\n  }\n`;\n\nconst ResultList = styled.ul`\n  ${resetList}\n  display: flex;\n  border-radius: 0 0 ${BORDER_RADIUS}px ${BORDER_RADIUS}px;\n  background: ${GRAY_300};\n  color: ${GRAY_900};\n  justify-content: space-between;\n  padding: ${SPACE_500}px;\n  font-family: monospace;\n  font-size: 24px;\n  font-weight: bold;\n  align-items: center;\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    padding: ${SPACE_600}px;\n  }\n\n  > * {\n    display: block;\n  }\n`;\n\nconst Character = styled.span`\n  opacity: ${({ children }) => (children === \"A\" ? 1 : 0.25)};\n`;\n\nconst UserItem = styled.div`\n  height: 100%;\n  width: 100%;\n  position: relative;\n  transition-property: opacity, transform;\n  transition-duration: ${SPEED_500}ms;\n  transform: scale(SCALE_500);\n\n  ${({ isUserDragging }) =>\n    isUserDragging &&\n    css`\n      opacity: 0.5;\n      pointer-events: none;\n      /* transform: scale(${SCALE_300}); */\n    `}\n\n  ${({ isDeleting, hasCapacityToDelete }) =>\n    isDeleting && hasCapacityToDelete && deleteAnimation(0.5)}\n`;\n\nconst Examples = styled.div`\n  /**\n   * Targeting the \"Base\" and \"Content\" hex values via CSS variables as the\n   * performance is more optimal than re-rendering a baked in value on every change.\n   *\n   * It also fixes an issue when referencing currentColor within a linear\n   * gradient (inconsistent in browsers).\n   */\n  --baseHex: ${({ baseHex }) => baseHex};\n  --contentHex: ${({ contentHex }) => contentHex};\n\n  border-radius: ${BORDER_RADIUS}px ${BORDER_RADIUS}px 0 0;\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-template-rows: auto;\n  grid-gap: ${SPACE_500}px;\n  background: var(--baseHex);\n  color: var(--contentHex);\n  padding: ${SPACE_500}px;\n  position: relative;\n  font-family: sans-serif;\n  transition: background ${SPEED_700}ms;\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    padding: ${SPACE_600}px;\n    grid-gap: ${SPACE_600}px;\n  }\n\n  > * {\n    display: block;\n  }\n\n  ${({ baseHex }) => {\n    /**\n     * Correspond with the <Swatch /> luminance aesthetic to differentiate VERY\n     * \"light\" colors from the application background.\n     */\n    if (checkHasLowLuminance(baseHex)) {\n      return css`\n        &:after {\n          ${positionAbsolute}\n          border-radius: ${BORDER_RADIUS}px ${BORDER_RADIUS}px 0 0;\n          box-shadow: ${LUMINANCE_SHADOW_500};\n          content: \"\";\n          display: block;\n        }\n      `;\n    }\n  }}\n`;\n\nconst SmallText = styled.span`\n  /**\n   * Force font size to be pixels (px) rather than something scaleable like rems\n   * so that we can force the \"worst case scenario\" when creating our color\n   * compositions.\n   */\n  display: block;\n  font-size: ${({ isBold }) => `${isBold ? 14 : 16}px`};\n  font-weight: ${({ isBold }) => (isBold ? \"bold\" : \"initial\")};\n`;\n\nconst Divider = styled.div`\n  border-radius: ${BORDER_RADIUS}px;\n  height: ${({ height }) => `${height}px`};\n  background-image: linear-gradient(to right, var(--contentHex), var(--baseHex));\n`;\n\nexport const Compositions = CompList;\n\nconst createContrastPercentage = (baseHex, contentHex) => {\n  const ratio = tinyColor.readability(baseHex, contentHex);\n  const percentage = (ratio / 21) * 100;\n\n  return Math.round(percentage);\n};\n\nconst createAccessibilityComparison = (baseHex, contentHex) => level =>\n  tinyColor.isReadable(baseHex, contentHex, { level, size: \"small\" });\n\nconst findAccessibilityLevel = (baseHex, contentHex) => {\n  const comparison = createAccessibilityComparison(baseHex, contentHex);\n\n  switch (true) {\n    case comparison(\"AAA\"):\n      return \"AAA\";\n    case comparison(\"AA\"):\n      return \"AA-\";\n    default:\n      return \"---\";\n  }\n};\n\nconst Icons = () => (\n  <div>\n    <IconList>\n      {[faCheckCircle, faCalendarAlt, faCommentDots, faStar, faTrashAlt].map((icon, index) => (\n        <li key={index}>\n          <FontAwesomeIcon {...{ icon }} />\n        </li>\n      ))}\n    </IconList>\n  </div>\n);\n\nconst Dividers = () => (\n  <div>\n    <DividerList>\n      {[1, 2, 4].map(height => (\n        <li key={height}>\n          <Divider {...{ height }} />\n        </li>\n      ))}\n    </DividerList>\n  </div>\n);\n\nconst Level = ({ children: level }) => {\n  const characters = level\n    .split(\"\")\n    .map((char, index) => <Character key={index}>{char}</Character>);\n\n  return <span>{characters}</span>;\n};\n\nconst DropAreas = styled.div`\n  ${positionAbsolute}\n  align-items: stretch;\n  display: grid;\n  grid-gap: ${SPACE_500}px;\n  justify-items: stretch;\n  padding: ${SPACE_600}px;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n\n  ${({ isUserDragging }) =>\n    !isUserDragging &&\n    css`\n      opacity: 0;\n      pointer-events: none;\n      transform: scale(${SCALE_600});\n    `}\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    grid-gap: ${SPACE_600}px;\n  }\n`;\n\nconst ResultIcon = styled(FontAwesomeIcon)`\n  transform: scale(${SCALE_600});\n`;\n\nconst Results = ({ baseHex, contentHex }) => {\n  const level = findAccessibilityLevel(baseHex, contentHex);\n  const icon = level.includes(\"AA\") ? faCheck : faTimes;\n  const percentage = createContrastPercentage(baseHex, contentHex);\n\n  return (\n    <div>\n      <ResultList>\n        <ResultIcon {...{ icon }} size=\"1x\" />\n        <Level>{level}</Level>\n        <span>{percentage}%</span>\n      </ResultList>\n    </div>\n  );\n};\n\nconst ItemWrapper = styled.li`\n  position: relative;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n\n  /** React CSSTransition animation property when an item is in its DORMANT state. */\n  &.composition-enter,\n  &.composition-exit,\n  &.composition-exit-active {\n    opacity: 0;\n    transform: scale(${SCALE_200});\n  }\n\n  /** React CSSTransition animation property when an item is in its ACTIVE state. */\n  &.composition-enter-active,\n  &.composition-enter-done {\n    opacity: 1;\n    transform: scale(${SCALE_500});\n  }\n`;\n\nconst AddCompositionButton = styled(AddButton)`\n  ${({ isActive }) =>\n    isActive\n      ? css`\n          opacity: 1;\n        `\n      : css`\n          opacity: 0;\n          pointer-events: none;\n        `}\n`;\n\nconst AddSlotButton = styled(AddButton)`\n  /**\n   * Hack for Safari, which does not confirm to positioning grid elements when\n   * the wrapper element has an opacity of 0. In that regard we staticky set\n   * the height of the slot 😩\n   */\n  min-height: 83px;\n\n  @media screen and (min-width: ${VIEWPORT_500}px) {\n    min-height: 115px;\n  }\n`;\n\nexport const UserComposition = memo(\n  ({\n    compId,\n    baseId,\n    contentId,\n    dragStartId,\n    baseHex,\n    contentHex,\n    dragHex,\n    isUserDragging,\n    isDeleting,\n    hasCapacityToDelete,\n    handleDelete,\n    handleDrop,\n    setActiveCompositionId,\n    removeActiveCompositionId\n  }) => {\n    const [isContentTargeted, setIsContentTargeted] = useState(false);\n    const [isBaseTargeted, setIsBaseTargeted] = useState(false);\n\n    return (\n      <ItemWrapper>\n        <UserItem\n          {...{ isUserDragging, isDeleting, hasCapacityToDelete }}\n          onPointerEnter={isDeleting ? undefined : () => setActiveCompositionId(compId)}\n          onPointerLeave={isDeleting ? undefined : removeActiveCompositionId}\n        >\n          <Examples {...{ baseHex, contentHex }}>\n            <SmallText>The quick brown fox,</SmallText>\n            <SmallText isBold>jumps over the lazy dog.</SmallText>\n            <Icons />\n            <Dividers />\n          </Examples>\n          <Results {...{ baseHex, contentHex }} />\n          <CSSTransition\n            unmountOnExit\n            in={isDeleting && hasCapacityToDelete}\n            timeout={SPEED_700}\n            classNames=\"deleteItem\"\n          >\n            <DeleteButton hex={GRAY_300} onClick={() => handleDelete(compId)}>\n              <FontAwesomeIcon icon={faTimes} size=\"1x\" />\n            </DeleteButton>\n          </CSSTransition>\n        </UserItem>\n        <DropAreas {...{ isUserDragging }}>\n          <AddSlotButton\n            hex={isContentTargeted ? dragHex : contentHex}\n            isTargeted={isContentTargeted}\n            onDragOver={event => {\n              setIsContentTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsContentTargeted(false)}\n            onDrop={event => {\n              handleDrop(compId, { contentId: dragStartId, baseId });\n              setIsContentTargeted(false);\n              setIsBaseTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n          <AddSlotButton\n            hex={isBaseTargeted ? dragHex : baseHex}\n            isTargeted={isBaseTargeted}\n            onDragOver={event => {\n              setIsBaseTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsBaseTargeted(false)}\n            onDrop={event => {\n              handleDrop(compId, { contentId, baseId: dragStartId });\n              setIsContentTargeted(false);\n              setIsBaseTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n        </DropAreas>\n      </ItemWrapper>\n    );\n  }\n);\n\nexport const AppendComposition = memo(\n  ({ dragHex, dragStartId, handleClick, handleDrop, isUserDragging }) => {\n    const [isAddTargeted, setIsAddTargeted] = useState(false);\n    const [isContentTargeted, setIsContentTargeted] = useState(false);\n    const [isBaseTargeted, setIsBaseTargeted] = useState(false);\n\n    return (\n      <AddItem>\n        <DropAreas {...{ isUserDragging }}>\n          <AddSlotButton\n            hex={isContentTargeted ? dragHex : GRAY_300}\n            isTargeted={isContentTargeted}\n            onDragOver={event => {\n              setIsContentTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsContentTargeted(false)}\n            onDrop={event => {\n              handleDrop({ contentId: dragStartId });\n              setIsContentTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n          <AddSlotButton\n            hex={isBaseTargeted ? dragHex : GRAY_300}\n            isTargeted={isBaseTargeted}\n            onDragOver={event => {\n              setIsBaseTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsBaseTargeted(false)}\n            onDrop={event => {\n              handleDrop({ baseId: dragStartId });\n              setIsContentTargeted(false);\n              setIsBaseTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n        </DropAreas>\n        <AddCompositionButton\n          hex={GRAY_300}\n          isActive={!isUserDragging}\n          isTargeted={isAddTargeted}\n          onClick={handleClick}\n          onPointerEnter={() => setIsAddTargeted(true)}\n          onPointerLeave={() => setIsAddTargeted(false)}\n        >\n          <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n        </AddCompositionButton>\n      </AddItem>\n    );\n  }\n);\n","import React, { memo, useEffect, useRef, useState } from \"react\";\nimport styled, { css } from \"styled-components\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faTrashAlt, faTasks } from \"@fortawesome/free-solid-svg-icons\";\nimport { faGithubAlt } from \"@fortawesome/free-brands-svg-icons\";\nimport {\n  BLACK,\n  GRAY_300,\n  GRAY_900,\n  COMP_WIDTH,\n  COMP_HEIGHT,\n  BORDER_RADIUS,\n  BORDER_WIDTH,\n  SCALE_200,\n  SCALE_300,\n  SCALE_500,\n  SCALE_600,\n  SPACE_400,\n  SPACE_500,\n  SPACE_600,\n  SPACE_800,\n  SPEED_500,\n  SPEED_700,\n  LUMINANCE_SHADOW_500,\n  createSwatch,\n  checkHasLowLuminance,\n  resetList,\n  positionAbsolute\n} from \"./utils\";\nimport { AddButton } from \"./Swatch\";\n\nconst Button = styled(AddButton)`\n  display: inline-flex;\n  align-items: center;\n  width: auto;\n  padding: 0 ${SPACE_500}px;\n  text-decoration: none;\n\n  > *:nth-child(1n + 2) {\n    margin-left: ${SPACE_400}px;\n  }\n`;\n\nconst ButtonHeader = styled.header`\n  height: ${SPACE_800}px;\n  display: flex;\n  justify-content: space-between;\n`;\n\nexport const Header = memo(({ isDeleting, handleDeleteToggle }) => (\n  <ButtonHeader>\n    <Button hex={GRAY_300} as=\"a\" href=\"https://github.com/devonChurch/avocado\">\n      <FontAwesomeIcon icon={faGithubAlt} size=\"1x\" />\n      <span>Github</span>\n    </Button>\n    <Button hex={GRAY_300} onClick={handleDeleteToggle}>\n      <FontAwesomeIcon icon={isDeleting ? faTasks : faTrashAlt} size=\"1x\" />\n      <span>{isDeleting ? \"Edit\" : \"Delete\"}</span>\n    </Button>\n  </ButtonHeader>\n));\n","import React, { useEffect, useRef } from \"react\";\nimport throttle from \"lodash.throttle\";\n\nexport const Scroll = () => {\n  const offset = useRef();\n  const throttledScroll = useRef();\n\n  useEffect(() => {\n    const setScroll = () => {\n      const { innerHeight, scrollY } = window;\n      const nextScroll = scrollY + offset.current;\n      const isTooHigh = nextScroll < 0;\n      const isTooLow = nextScroll > document.body.clientHeight - innerHeight;\n      const shouldScroll = !isTooHigh && !isTooLow;\n\n      if (shouldScroll) {\n        window.scroll(0, nextScroll);\n        throttledScroll.current = requestAnimationFrame(setScroll);\n      } else {\n        throttledScroll.current = null;\n      }\n    };\n\n    const checkScenario = event => {\n      const viewPortHeight = window.innerHeight;\n      const viewPortQuarter = viewPortHeight / 4;\n      const pointerPosition = event.clientY;\n      const isOverTopQuarter = pointerPosition < viewPortQuarter;\n      const isOverBottomQuarter = pointerPosition > viewPortQuarter * 3;\n      const maxScrollOffset = viewPortQuarter;\n      const shouldUpdateScroll =\n        !throttledScroll.current && (isOverTopQuarter || isOverBottomQuarter);\n      const shouldStopScroll =\n        throttledScroll.current && !(isOverTopQuarter || isOverBottomQuarter);\n\n      if (isOverTopQuarter) {\n        const percentageOffset = (viewPortQuarter - pointerPosition) / viewPortQuarter;\n        const pixelOffset = maxScrollOffset * percentageOffset;\n        offset.current = -pixelOffset;\n      }\n\n      if (isOverBottomQuarter) {\n        const percentageOffset = (pointerPosition - viewPortQuarter * 3) / viewPortQuarter;\n        const pixelOffset = maxScrollOffset * percentageOffset;\n        offset.current = pixelOffset;\n      }\n\n      if (shouldUpdateScroll) {\n        throttledScroll.current = requestAnimationFrame(setScroll);\n      }\n\n      if (shouldStopScroll) {\n        throttledScroll.current = null;\n      }\n    };\n\n    const handlePointerMove = event => {\n      checkScenario(event);\n    };\n\n    const throttledDrag = throttle(handlePointerMove, 250, { trailing: false });\n\n    window.addEventListener(\"dragover\", throttledDrag);\n\n    return function cleanUp() {\n      throttledScroll.current = null;\n      window.removeEventListener(\"dragover\", handlePointerMove);\n    };\n  }, []);\n\n  return null;\n};\n","import \"normalize.css\";\nimport \"drag-drop-touch\";\nimport React, { useCallback, useMemo, useRef, useState, useEffect } from \"react\";\nimport { TransitionGroup, CSSTransition } from \"react-transition-group\";\nimport nanoid from \"nanoid\";\nimport throttle from \"lodash.throttle\";\nimport { createGlobalStyle } from \"styled-components\";\nimport { Swatches, UserSwatch, AppendSwatch } from \"./Swatch\";\nimport { Compositions, UserComposition, AppendComposition } from \"./Composition\";\nimport { Header } from \"./Header\";\nimport { Scroll } from \"./Scroll\";\nimport {\n  SWATCH_WIDTH,\n  BLACK,\n  SPACE_500,\n  SPACE_600,\n  SPACE_800,\n  SPEED_500,\n  SPEED_700,\n  VIEWPORT_500,\n  WHITE,\n  findColorComplementFromSwatches,\n  createSwatch,\n  convertStateToQuery,\n  convertStateFromQuery\n} from \"./utils\";\n\nconst GlobalStyle = createGlobalStyle`\n  html {\n    box-sizing: border-box;\n  }\n  \n  *, *:before, *:after {\n    box-sizing: inherit;\n  }\n\n  body {\n    padding: ${SPACE_500}px;\n\n    @media screen and (min-width: ${VIEWPORT_500}px) {\n      padding: ${SPACE_800}px;\n    }\n  }\n\n  #root {\n    display: grid;\n    grid-gap: ${SPACE_500}px;\n\n    @media screen and (min-width: ${VIEWPORT_500}px) {\n      grid-gap: ${SPACE_600}px;\n    }\n  }\n`;\n\nconst createSwatchKey = () => nanoid();\nconst createCompositionKey = createSwatchKey;\n\nconst createIndexComparison = idOne => ([idTwo]) => idOne === idTwo;\nconst findSwatchIndexFromId = (swatches, id) => swatches.findIndex(createIndexComparison(id));\nconst findCompositionIndexFromId = (compositions, id) =>\n  compositions.findIndex(createIndexComparison(id));\n\nconst createReorderTransform = (x = 0, y = 0) => `transform: translate(${x}%, ${y}%);`;\n\n/**\n * Returns a thunk that can calculate the CSS transformation that reorders swatches\n * that the user drags over based not he origin of the dragged swatch.\n */\nconst calculateReorderTransform = (swatches, dragStartId, dragOverId, swatchIndex) => {\n  /** Only calculate if we have the relevant information. */\n  const isInDragOverState = dragStartId && dragOverId && dragStartId !== dragOverId;\n  if (!isInDragOverState) return createReorderTransform;\n\n  /** Only calculate if the current swatch is not the originating dragging swatch. */\n  const dragStartIndex = findSwatchIndexFromId(swatches, dragStartId);\n  const dragOverIndex = findSwatchIndexFromId(swatches, dragOverId);\n  const shouldReorder = dragStartIndex !== swatchIndex;\n  if (!shouldReorder) return createReorderTransform;\n\n  /**\n   * Only calculate is the current swatch falls between the originating dragged\n   * swatch and the dragged over swatch. All outside swatches remain static.\n   */\n  const isBeforeDragSwatches = swatchIndex >= dragStartIndex || swatchIndex >= dragOverIndex;\n  const isAfterDragSwatches = swatchIndex <= dragStartIndex || swatchIndex <= dragOverIndex;\n  const isBetweenDragSwatches = isBeforeDragSwatches && isAfterDragSwatches;\n  if (!isBetweenDragSwatches) return createReorderTransform;\n\n  /**\n   * Based on the direction (\"left\" or \"right\") that the user is dragging we\n   * reorder the swatches that fall between the dragging indexes to fill the gap\n   * left from the originating dragged swatch.\n   */\n  return function positionReorderTransform(prevNode) {\n    const isDraggedRight = dragStartIndex > swatchIndex;\n    const siblingTarget = isDraggedRight ? \"nextElementSibling\" : \"previousElementSibling\";\n    const nextNode = prevNode[siblingTarget];\n    const { offsetTop: prevY, offsetLeft: prevX } = prevNode;\n    const { offsetTop: nextY, offsetLeft: nextX } = nextNode;\n    const dragX = ((nextX - prevX) / SWATCH_WIDTH) * 100;\n    const dragY = ((nextY - prevY) / SWATCH_WIDTH) * 100;\n\n    return createReorderTransform(dragX, dragY);\n  };\n};\n\nconst useThrottledState = (initialState, delay) => {\n  const [isPrepped, setIsPrepped] = useState(false);\n  const [state, setState] = useState(initialState);\n  const throttled = useRef();\n\n  useEffect(() => {\n    const handleUpdate = newState => setState(newState);\n    throttled.current = throttle(handleUpdate, delay, { trailing: false });\n\n    // Once the throttler has been setup we toggle a flag to ensure that we return\n    // the throttled state \"updater\"\n    if (!isPrepped) {\n      setIsPrepped(true);\n    }\n\n    // Destroy persistent throttle reference on unmount.\n    return () => throttled.current.cancel();\n\n    // Force the effect to ONLY run on init so as NOT to recreate the thriller\n    // setup (which would be super bad).\n  }, []);\n\n  return [\n    state,\n    // If we have NOT prepped the throttler yet then just send back the \"immediate\"\n    // setState reference.\n    isPrepped ? throttled.current : setState\n  ];\n};\n\nconst App = () => {\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** SWATCHES:   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n\n  // Se swap out the \"vanilla\" useState hook for a custom implementation that\n  // throttles the update of the \"swatches\" references. The swatch state is the\n  // catalyst for performant heavy re-renders (think hundreds of hex updates as\n  // you drag the native color slider). In that regard, we throttle the amount\n  // the swatches state can be updated.\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  // const [swatches, setSwatches] = useState([]);\n  const [swatches, setSwatches] = useThrottledState(new Map([]), 1000);\n\n  const [dragStartId, setDragStartId] = useState(null);\n  const [dragOverId, setDragOverId] = useState(null);\n  const isUserDragging = !!dragStartId;\n  const dragHex = isUserDragging && swatches.get(dragStartId);\n\n  const removeDragStartId = () => setDragStartId(null);\n  const removeDragOverId = useCallback(() => setDragOverId(null), []);\n  const removeDragIds = useCallback(() => {\n    removeDragStartId(null);\n    removeDragOverId(null);\n  }, [removeDragOverId]);\n\n  const appendSwatch = hex => setSwatches(new Map([...swatches, [createSwatchKey(), hex]]));\n\n  const appendLastListedSwatch = () => {\n    const [, lastHex] = [...swatches].pop() || [];\n    appendSwatch(lastHex || BLACK);\n  };\n\n  const appendDraggedSwatch = () => {\n    appendSwatch(dragHex);\n    removeDragIds();\n  };\n\n  const updateUserSwatch = useCallback(\n    (id, hex) => setSwatches(new Map([...swatches, [id, hex]])),\n    [swatches]\n  );\n\n  const moveSwatchToNewLocation = useCallback(\n    dropId => {\n      if (dragStartId === dropId) return;\n\n      const prevSwatches = [...swatches];\n      const dropIndex = findSwatchIndexFromId(prevSwatches, dropId);\n      const dragStartIndex = findSwatchIndexFromId(prevSwatches, dragStartId);\n      const shoudPrepend = dropIndex < dragStartIndex;\n      const dropSwatch = [dragStartId, swatches.get(dragStartId)];\n      const nextSwatches = new Map(\n        prevSwatches.reduce((acc, [id, hex]) => {\n          switch (true) {\n            case id === dragStartId:\n              return acc; // Remove the swatch from its orignal location.\n            case id === dropId:\n              return shoudPrepend\n                ? [...acc, dropSwatch, [id, hex]]\n                : [...acc, [id, hex], dropSwatch];\n            default:\n              return [...acc, [id, hex]];\n          }\n        }, [])\n      );\n      setSwatches(nextSwatches);\n      removeDragIds();\n    },\n    [swatches, dragStartId, removeDragIds]\n  );\n\n  const createReorderTransformHandler = (...args) =>\n    calculateReorderTransform([...swatches], ...args);\n\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** COMPOSITIONS:  ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n  const [compositions, setCompositions] = useState([]);\n\n  const [activeCompositionId, setActiveCompositionId] = useState(null);\n  const removeActiveCompositionId = () => setActiveCompositionId(null);\n\n  const setSwatchAppearanceAgainstCompositionTarget = swatchId => {\n    if (!activeCompositionId) return;\n    const composition = compositions.get(activeCompositionId);\n    const hasBase = composition.baseId === swatchId;\n    const hasContent = composition.contentId === swatchId;\n    const shouldSwatchPronounce = hasBase || hasContent;\n    const shouldSwatchRegress = !shouldSwatchPronounce && activeCompositionId;\n\n    return { shouldSwatchPronounce, shouldSwatchRegress };\n  };\n\n  const appendComposition = ({ baseId, contentId } = {}) => {\n    const compositionIds = {\n      baseId: baseId || findColorComplementFromSwatches(contentId, swatches),\n      contentId: contentId || findColorComplementFromSwatches(baseId, swatches)\n    };\n    setCompositions(new Map([...compositions, [createCompositionKey(), compositionIds]]));\n  };\n\n  const appendLastListedComposition = () => {\n    const [, compositionIds] = [...compositions].pop() || [];\n    appendComposition(compositionIds);\n  };\n\n  const appendCompositionFromDraggedSwatch = compositionIds => {\n    appendComposition(compositionIds);\n    removeDragIds();\n  };\n\n  const updateComposition = useCallback(\n    (compId, composition) => {\n      const prevComps = [...compositions];\n      const compIndex = findCompositionIndexFromId(prevComps, compId);\n      const nextComps = [\n        ...prevComps.slice(0, compIndex),\n        [compId, composition],\n        ...prevComps.slice(compIndex + 1)\n      ];\n      setCompositions(new Map(nextComps));\n    },\n    [compositions]\n  );\n\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** QUERY STRING:  ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n\n  useEffect(() => {\n    const { swatches, compositions } = convertStateFromQuery(window.location.search);\n\n    setSwatches(swatches);\n    setCompositions(compositions);\n  }, []);\n\n  useEffect(() => {\n    const search = convertStateToQuery(swatches, compositions);\n    const { protocol, host, pathname } = window.location;\n    const url = `${protocol}//${host}${pathname}${search}`;\n\n    window.history.replaceState({}, \"\", url);\n  }, [swatches, compositions]);\n\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** DELETE:  ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n\n  const [isDeleting, setIsDeleting] = useState(false);\n  const handleDeleteToggle = () => setIsDeleting(!isDeleting);\n\n  const deleteSwatch = useCallback(\n    swatchId => {\n      const prevSwatches = [...swatches];\n      const swatchIndex = findSwatchIndexFromId(prevSwatches, swatchId);\n      const nextSwatches = [\n        ...prevSwatches.slice(0, swatchIndex),\n        ...prevSwatches.slice(swatchIndex + 1)\n      ];\n      setSwatches(new Map(nextSwatches));\n    },\n    [swatches]\n  );\n\n  const deleteComposition = useCallback(\n    compId => {\n      const prevComps = [...compositions];\n      const compIndex = findCompositionIndexFromId(prevComps, compId);\n      const nextComps = [...prevComps.slice(0, compIndex), ...prevComps.slice(compIndex + 1)];\n      setCompositions(new Map(nextComps));\n    },\n    [compositions]\n  );\n\n  const hasEnoughSwatchesToDelete = swatches.size > 2;\n  const hasEnoughCompositionsToDelete = compositions.size > 1;\n\n  const checkIsSwatchInAnyComposition = (() => {\n    const activeSwatchIds = [...compositions.values()].reduce(\n      (acc, { baseId, contentId }) => [...acc, baseId, contentId],\n      []\n    );\n\n    return swatchId => activeSwatchIds.includes(swatchId);\n  })();\n\n  return (\n    <>\n      <GlobalStyle />\n      <Header {...{ isDeleting, handleDeleteToggle }} />\n      {isUserDragging && <Scroll />}\n      <TransitionGroup component={Swatches}>\n        {[...swatches].map(([swatchId, hex], swatchIndex) => (\n          <CSSTransition key={swatchId} timeout={SPEED_700} classNames=\"swatch\">\n            <UserSwatch\n              key={swatchId}\n              {...{\n                swatchId,\n                hex,\n                isUserDragging,\n                isDeleting,\n                ...setSwatchAppearanceAgainstCompositionTarget(swatchId)\n              }}\n              hasCapacityToDelete={\n                hasEnoughSwatchesToDelete && !checkIsSwatchInAnyComposition(swatchId)\n              }\n              handleChange={updateUserSwatch}\n              handleDragStart={setDragStartId}\n              handleDragOver={setDragOverId}\n              handleDragExit={removeDragOverId}\n              handleDragEnd={removeDragIds}\n              handleDrop={moveSwatchToNewLocation}\n              handleDelete={deleteSwatch}\n              createReorderTransform={createReorderTransformHandler(\n                dragStartId,\n                dragOverId,\n                swatchIndex\n              )}\n            />\n          </CSSTransition>\n        ))}\n        <>\n          {/**\n           * Use a <Fragment /> to protect the \"append\" <CSSTransitions /> from\n           * absorbing the parent <TransitionGroup />.\n           */\n          isDeleting ? (\n            /**\n             * Add in a placeholder so that the missing space does NOT cause\n             * aggressive reflow.\n             */\n            <div />\n          ) : (\n            <CSSTransition unmountOnExit in={!isDeleting} timeout={SPEED_700} classNames=\"addItem\">\n              <AppendSwatch\n                {...{ dragHex }}\n                handleClick={appendLastListedSwatch}\n                handleDrop={appendDraggedSwatch}\n              />\n            </CSSTransition>\n          )}\n        </>\n      </TransitionGroup>\n      <TransitionGroup component={Compositions}>\n        {[...compositions].map(([compId, { baseId, contentId }]) => (\n          <CSSTransition key={compId} timeout={SPEED_700} classNames=\"composition\">\n            <UserComposition\n              key={compId}\n              {...{\n                compId,\n                baseId,\n                contentId,\n                dragStartId,\n                dragHex,\n                isUserDragging,\n                isDeleting,\n                setActiveCompositionId,\n                removeActiveCompositionId\n              }}\n              hasCapacityToDelete={hasEnoughCompositionsToDelete}\n              baseHex={swatches.get(baseId)}\n              contentHex={swatches.get(contentId)}\n              handleDrop={updateComposition}\n              handleDelete={deleteComposition}\n            />\n          </CSSTransition>\n        ))}\n        <>\n          {isDeleting ? (\n            <div />\n          ) : (\n            <CSSTransition unmountOnExit in={!isDeleting} timeout={SPEED_700} classNames=\"addItem\">\n              <AppendComposition\n                {...{ dragStartId, dragHex, isUserDragging }}\n                handleClick={appendLastListedComposition}\n                handleDrop={appendCompositionFromDraggedSwatch}\n              />\n            </CSSTransition>\n          )}\n        </>\n      </TransitionGroup>\n    </>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n// import * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}