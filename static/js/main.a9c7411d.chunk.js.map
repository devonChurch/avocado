{"version":3,"sources":["utils.js","Swatch.js","Composition.js","Header.js","App.js","index.js"],"names":["createSwatch","hex","tinyColor","FOCUS_SHADOW_500","setAlpha","LUMINANCE_SHADOW_500","findColorComplementFromSwatches","compareId","swatches","compareHex","get","hexes","values","complementHex","mostReadable","toHexString","entries","find","checkHasLowLuminance","getLuminance","updateLuminanceStatic","lighten","darken","isLuminant","luminance","createColorCompanion","createUpdate","alpha","prevSwatch","toHsl","luminanceBefore","l","nextSwatch","toString","createOffsetColor","createFocusColor","createActiveColor","createFocusborder","createFocusStateWithShadow","resetList","css","positionAbsolute","defaultSwatches","Map","defaultCompositions","baseId","contentId","deleteAnimation","offset","keyframes","deleteKeyframes","SwatchList","styled","ul","UserItem","div","isUserDragging","isDragged","isAboutToDrag","shouldSwatchRegress","isDeleting","styles","createFocusState","swatchActiveState","DragHitBox","li","shouldSwatchPronounce","hasCapacityToDelete","ReorderTransformation","reorderTransform","AddItem","AddButton","button","isTargeted","createTargetColor","Input","input","DeleteButton","Swatches","UserSwatch","memo","swatchId","handleChange","handleDragStart","handleDragOver","handleDragExit","handleDragEnd","handleDrop","handleDelete","createReorderTransform","useState","setIsDragged","setIsAboutToDrag","inputValue","setInputValue","debouncedInputHandler","debounce","value","swatchRef","useRef","draggable","ref","onDragStart","event","dataTransfer","setData","setDragImage","current","SWATCH_WIDTH","onDragEnd","onDragOver","preventDefault","onDragLeave","onDrop","onMouseDown","undefined","onMouseUp","CSSTransition","unmountOnExit","in","timeout","classNames","onClick","icon","faPlus","size","type","onChange","target","AppendSwatch","dragHex","handleClick","setIsTargeted","onMouseEnter","onMouseLeave","CompList","SPACE_500","IconList","DividerList","ResultList","Character","span","children","Examples","baseHex","contentHex","SmallText","isBold","Divider","height","Compositions","findAccessibilityLevel","comparison","level","isReadable","createAccessibilityComparison","Icons","faCheckCircle","faCalendarAlt","faCommentDots","faStar","faTrashAlt","map","index","key","Dividers","Level","characters","split","char","DropAreas","ResultIcon","FontAwesomeIcon","Results","includes","faCheck","faTimes","percentage","readability","Math","round","createContrastPercentage","ItemWrapper","AddCompositionButton","isActive","AddSlotButton","UserComposition","compId","dragStartId","setActiveCompositionId","removeActiveCompositionId","isContentTargeted","setIsContentTargeted","isBaseTargeted","setIsBaseTargeted","AppendComposition","isAddTargeted","setIsAddTargeted","Button","ButtonHeader","header","Header","handleDeleteToggle","as","href","faGithubAlt","faTasks","GlobalStyle","createGlobalStyle","createSwatchKey","nanoid","createCompositionKey","createIndexComparison","idOne","idTwo","findSwatchIndexFromId","id","findIndex","findCompositionIndexFromId","compositions","x","y","calculateReorderTransform","dragOverId","swatchIndex","dragStartIndex","dragOverIndex","prevNode","nextNode","prevY","offsetTop","prevX","offsetLeft","nextY","nextX","App","initialState","delay","isPrepped","setIsPrepped","state","setState","throttled","useEffect","throttle","newState","trailing","cancel","useThrottledState","setSwatches","setDragStartId","setDragOverId","removeDragOverId","useCallback","removeDragIds","appendSwatch","updateUserSwatch","moveSwatchToNewLocation","dropId","prevSwatches","shoudPrepend","dropSwatch","nextSwatches","reduce","acc","createReorderTransformHandler","args","setCompositions","activeCompositionId","appendComposition","compositionIds","updateComposition","composition","prevComps","compIndex","nextComps","slice","search","qs","parse","ignoreQueryPrefix","s","c","swatchMap","compMap","hasUserConfig","convertStateFromQuery","window","location","swatchFlat","swatchKeys","keys","compFlat","indexOf","stringify","addQueryPrefix","convertStateToQuery","protocol","host","pathname","url","history","replaceState","setIsDeleting","deleteSwatch","deleteComposition","hasEnoughSwatchesToDelete","hasEnoughCompositionsToDelete","checkIsSwatchInAnyComposition","activeSwatchIds","TransitionGroup","component","hasBase","hasContent","setSwatchAppearanceAgainstCompositionTarget","pop","lastHex","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a9c7411d.chunk.js","sourcesContent":["import { css, keyframes } from \"styled-components\";\nimport tinyColor from \"tinycolor2\";\nimport qs from \"qs\";\n\nexport const createSwatch = hex => tinyColor(hex);\n\nexport const SPACE_300 = 4;\nexport const SPACE_400 = 8;\nexport const SPACE_500 = 16;\nexport const SPACE_600 = 24;\nexport const SPACE_700 = 32;\nexport const SPACE_800 = 40;\n\nexport const SWATCH_WIDTH = 80;\nexport const BORDER_WIDTH = 3;\nexport const FOCUS_WIDTH = 3;\nexport const COMP_WIDTH = SPACE_500 * 16;\nexport const COMP_HEIGHT = SPACE_500 * 18;\n\nexport const BORDER_RADIUS = 4;\n\nexport const WHITE = \"#fff\";\nexport const BLACK = \"#000\";\n\nexport const GRAY_100 = \"#EAF0EE\";\nexport const GRAY_300 = \"#c8d5d1\";\nexport const GRAY_500 = \"#8DA79F\";\nexport const GRAY_700 = \"#5c716b\";\nexport const GRAY_900 = \"#40504C\";\n\nexport const SPEED_500 = 250;\nexport const SPEED_700 = 500;\n\nexport const SCALE_200 = 0.5;\nexport const SCALE_300 = 0.8;\nexport const SCALE_400 = 0.9;\nexport const SCALE_500 = 1;\nexport const SCALE_600 = 1.1;\n\nexport const FOCUS_SHADOW_500 = `0 0 13px ${FOCUS_WIDTH}px ${createSwatch(BLACK).setAlpha(0.25)}`;\n\nexport const LUMINANCE_SHADOW_500 = `inset 0 0 0 ${BORDER_WIDTH}px ${createSwatch(BLACK).setAlpha(\n  0.1\n)}`;\n\nexport const findColorComplementFromSwatches = (compareId, swatches) => {\n  const compareHex = swatches.get(compareId);\n  const hexes = [...swatches.values()];\n  const complementHex = tinyColor.mostReadable(compareHex, hexes).toHexString();\n  const [complementId] = [...swatches.entries()].find(([, hex]) => hex === complementHex);\n\n  return complementId;\n};\n\nexport const checkHasLowLuminance = hex => createSwatch(hex).getLuminance() > 0.9;\n\nconst updateLuminanceStatic = (lighten, darken) => (isLuminant, luminance) =>\n  isLuminant ? lighten : darken;\n\nconst updateLuminanceDynamic = percentage => (isLuminant, luminance) => {\n  const offset = (luminance * percentage) / 100;\n  return isLuminant ? Math.max(luminance - offset, 0) : Math.min(luminance + offset, 100);\n};\n\nconst createColorCompanion = (createUpdate, alpha = 1) => hex => {\n  const prevSwatch = createSwatch(hex).toHsl();\n  const { l: luminanceBefore } = prevSwatch;\n  const isLuminant = luminanceBefore > 0.6;\n  const luminanceAfter = createUpdate(isLuminant, luminanceBefore);\n  const nextSwatch = { ...prevSwatch, l: luminanceAfter };\n\n  return tinyColor(nextSwatch)\n    .setAlpha(alpha)\n    .toString();\n};\n\nexport const createOffsetColor = createColorCompanion(updateLuminanceStatic(0.2, 0.8));\nexport const createTargetColor = hex => hex;\nexport const createFocusColor = createColorCompanion(updateLuminanceStatic(0.3, 0.7), 0.5);\nexport const createActiveColor = createColorCompanion(updateLuminanceStatic(0.5, 0.5), 1);\n\nexport const createFocusborder = hex => `0 0 0 ${FOCUS_WIDTH}px ${createFocusColor(hex)}`;\nexport const createFocusState = hex => createFocusborder(hex);\nexport const createFocusStateWithShadow = hex => `${FOCUS_SHADOW_500}, ${createFocusborder(hex)}`;\n\nexport const resetList = css`\n  list-style: none;\n  margin: 0;\n  padding: 0;\n`;\n\nexport const positionAbsolute = css`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n`;\n\nconst defaultSwatches = new Map([\n  [\"1\", createSwatch(\"rgb(88, 213, 255)\").toHexString()],\n  [\"2\", createSwatch(\"rgb(246, 199, 163)\").toHexString()],\n  [\"3\", createSwatch(\"rgb(240, 124, 125)\").toHexString()],\n  [\"4\", createSwatch(\"rgb(218, 68, 93)\").toHexString()],\n  [\"5\", createSwatch(\"rgb(38, 51, 56)\").toHexString()]\n]);\n\nconst defaultCompositions = new Map([\n  [\"1\", { baseId: \"5\", contentId: \"1\" }],\n  [\"2\", { baseId: \"4\", contentId: \"2\" }],\n  [\"3\", { baseId: \"2\", contentId: \"5\" }]\n]);\n\nexport const convertStateToQuery = (swatches, compositions) => {\n  const swatchFlat = [...swatches.values()];\n  const swatchKeys = [...swatches.keys()];\n  const compFlat = [...compositions.values()].map(({ baseId, contentId }) => [\n    swatchKeys.indexOf(baseId),\n    swatchKeys.indexOf(contentId)\n  ]);\n\n  return qs.stringify({ s: swatchFlat, c: compFlat }, { addQueryPrefix: true });\n};\n\nexport const convertStateFromQuery = search => {\n  const { s: swatches = [], c: compositions = [] } = qs.parse(search, { ignoreQueryPrefix: true });\n  const swatchMap = new Map(swatches.map((value, index) => [`${index}`, value]));\n  const compMap = new Map(\n    compositions.map(([baseId, contentId], index) => [`${index}`, { baseId, contentId }])\n  );\n  const hasUserConfig = swatchMap.size || compMap.size;\n\n  return {\n    swatches: hasUserConfig ? swatchMap || [] : defaultSwatches,\n    compositions: hasUserConfig ? compMap || [] : defaultCompositions\n  };\n};\n\nexport const deleteKeyframes = offset => keyframes`\n  from {\n    transform: rotate(-${offset}deg);\n  }\n\n  to {\n    transform: rotate(${offset}deg);\n  }\n`;\n\nexport const deleteAnimation = offset => css`\n  transform-origin: right top;\n  animation: 0.1s infinite alternate ${deleteKeyframes(offset)};\n  animation-timing-function: ease-in-out;\n`;\n","import React, { memo, useState, useEffect, useRef, useCallback } from \"react\";\nimport { CSSTransition } from \"react-transition-group\";\nimport styled, { css } from \"styled-components\";\nimport debounce from \"lodash.debounce\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faPlus, faArrowsAlt } from \"@fortawesome/free-solid-svg-icons\";\nimport {\n  SWATCH_WIDTH,\n  BORDER_WIDTH,\n  BORDER_RADIUS,\n  WHITE,\n  BLACK,\n  GRAY_300,\n  GRAY_500,\n  GRAY_900,\n  SPEED_500,\n  SPEED_700,\n  SCALE_300,\n  SCALE_400,\n  SCALE_500,\n  SCALE_600,\n  SPACE_300,\n  SPACE_400,\n  SPACE_500,\n  SPACE_600,\n  SPACE_700,\n  LUMINANCE_SHADOW_500,\n  createSwatch,\n  createOffsetColor,\n  createTargetColor,\n  createFocusState,\n  createActiveColor,\n  createFocusStateWithShadow,\n  checkHasLowLuminance,\n  resetList,\n  positionAbsolute,\n  deleteAnimation\n} from \"./utils\";\n\nconst SwatchList = styled.ul`\n  ${resetList}\n  display: grid;\n  grid-gap: 0;\n  grid-template-rows: repeat(auto-fill, ${SWATCH_WIDTH}px);\n  grid-template-columns: repeat(auto-fill, ${SWATCH_WIDTH}px);\n\n  /** Regardless of content we ALWAYS conform to the rigid grid system dimensions. */\n  > * {\n    height: ${SWATCH_WIDTH}px;\n    width: ${SWATCH_WIDTH}px;\n  }\n`;\n\nconst UserItem = styled.div`\n  ${positionAbsolute}\n  background: ${({ hex }) => hex};\n  /* pointer-events: none; */\n  transition-duration: ${SPEED_700}ms, ${SPEED_500}ms, ${SPEED_700}ms, ${SPEED_700}ms;\n  transition-property: background, box-shadow, transform, border;\n\n  ${({ hex, isUserDragging, isDragged, isAboutToDrag, shouldSwatchRegress, isDeleting }) => {\n    let styles = \"\";\n\n    /**\n     * If a swatch color the user has selected has VERY LOW luminance (white or\n     * close to white) then the swatch will blend into the application background\n     * (and effectively dissapear).\n     *\n     * In that regard, we add a slightly darker border around the color to\n     * differentiate it from the background (if it needs it).\n     */\n    if (checkHasLowLuminance(hex)) {\n      styles += `\n        &:after {\n          ${positionAbsolute}\n          border-radius: 4px;\n          box-shadow: ${LUMINANCE_SHADOW_500};\n          content: \"\";\n          display: block;\n          transition: opacity ${SPEED_500}ms;\n        }\n      `;\n    }\n\n    if (isDragged || isUserDragging || isAboutToDrag || shouldSwatchRegress || isDeleting) {\n      styles += `\n        border-radius: ${BORDER_RADIUS}px;\n      `;\n    }\n\n    if (isUserDragging || isDeleting) {\n      styles += `\n        transform: scale(${SCALE_300});\n      `;\n    }\n\n    /**\n     * We want the original location where the swatch was dragged from to be an\n     * \"empty\" slot (by default it just sits there).\n     *\n     * + If we change `opacity: 0;` then that ALSO changes the dragged item\n     *   attached to the users mouse position.\n     *\n     * + Changing `background: white;` ONLY changes the placeholder \"dormant\"\n     *   swatch =)\n     */\n    if (isDragged && isUserDragging) {\n      styles += `\n        background: ${WHITE};\n      `;\n    }\n\n    /**\n     * The browser will take a \"snapshot\" or the dragged swatch IMMEDIATELY after\n     * dragging starts. The \"snapshot\" is a square around the DOM element and\n     * crops out anything NOT in that box (like `outline` and `box-shadow`). In\n     * that regard we need to have the dragging swatch BEFORE dragging starts.\n     *\n     * To do this we remove and `transition-duration` (so that things happen\n     * immediately - getting caught half way through a transition looks disjointed)\n     * and change the following:\n     *\n     * + `scale` shrink the main item (including `:focus` `box-shadow`) INSIDE\n     *   the crop box. This actually look pretty good as it simulates an \"on press\"\n     *   aesthetic.\n     *\n     * + Remove the drop shadow as it bleeds off the swatch crop area and can be\n     *   seen in the swatch rounded corners.\n     */\n    if (isAboutToDrag) {\n      styles += `\n        box-shadow: ${({ hex }) => createFocusState(hex)} !important;\n        transition-duration: 0ms;\n        transform: scale(${SCALE_400});\n      `;\n    }\n\n    return css`\n      ${styles}\n    `;\n  }}\n`;\n\nconst swatchActiveState = css`\n  z-index: 10;\n\n  ${UserItem} {\n    box-shadow: ${({ hex }) => createFocusStateWithShadow(hex)};\n    border-radius: ${BORDER_RADIUS}px;\n    outline: 0;\n\n    &:after {\n      opacity: 0;\n    }\n  }\n`;\n\nconst DragHitBox = styled.li`\n  position: relative;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n  /**\n   * When an item is being dragged we send it to the BACK so that ALL other\n   * swatches can overlap when the \"recording\" animation is running. The dragging\n   * swatch is also completely white and therefore CANNOT reside on top of\n   * anything else.\n   */\n  z-index: ${({ isDragged }) => (isDragged ? \"0\" : \"1\")};\n\n  ${({ isUserDragging, isDeleting }) =>\n    !isUserDragging &&\n    !isDeleting &&\n    /**\n     * Do NOT show these interaction states on ANY swatches when the user is\n     * dragging as swatches will all be changing their `:hover` states on/off\n     * throughout the dragging process.\n     */\n    css`\n      &:focus-within,\n      &:hover {\n        ${swatchActiveState}\n      }\n    `}\n\n  ${({ shouldSwatchRegress }) =>\n    shouldSwatchRegress &&\n    css`\n      opacity: 0.25;\n      transform: scale(${SCALE_300});\n    `}\n\n  ${({ shouldSwatchPronounce }) => shouldSwatchPronounce && swatchActiveState}\n\n  ${({ isDeleting, hasCapacityToDelete }) =>\n    isDeleting && hasCapacityToDelete && deleteAnimation(2)}\n\n  /** React CSSTransition animation property when an item is in its DORMANT state. */\n  &.swatch-enter,\n  &.swatch-exit,\n  &.swatch-exit-active {\n    opacity: 0;\n    transform: scale(0);\n  }\n\n  /** React CSSTransition animation property when an item is in its ACTIVE state. */\n  &.swatch-enter-active,\n  &.swatch-enter-done {\n    opacity: 1;\n    transform: scale(${SCALE_500});\n  }\n`;\n\nconst ReorderTransformation = styled.div`\n  ${positionAbsolute}\n  transition: ${SPEED_500}ms;\n\n  ${({ reorderTransform }) =>\n    css`\n      ${reorderTransform}\n    `}\n\n  ${({ isUserDragging }) => {\n    /*\n     * When a users is dragging a `<Swatch />` we want the \"re-order\" animation\n     * (simulated via CSS `transform`'s) to run.\n     *\n     * When however, the user drops a `<Swatch />` we want the items to \"re-order\"\n     * in the DOM (hard-coded NOT simulated). In that regard, if we are still\n     * running `transition`s on the now redundant `transform`'s then we get a\n     * flicker as the `<Swatch />` move back to their dormant state. When we apply\n     * NO `transition` the drop effect feel \"solid\".\n     */\n    switch (isUserDragging) {\n      case true:\n        return css`\n          transition-property: transform;\n        `;\n      default:\n        return css`\n          transition-property: none;\n        `;\n    }\n  }}\n`;\n\nexport const AddItem = styled.li`\n  /** Force contents to take up ALL of the \"cells\" x/y space. */\n  display: grid;\n  padding: ${SPACE_400}px;\n  position: relative;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n\n  /** React CSSTransition animation property when the add <button /> is in NOT ACTIVE. */\n  &.addItem-enter,\n  &.addItem-exit {\n    opacity: 0;\n    transform: scale(${SCALE_300});\n  }\n\n  /** React CSSTransition animation property when the add <button /> is in IS ACTIVE. */\n  &.addItem-enter-active {\n    opacity: 1;\n    transform: scale(${SCALE_500});\n  }\n`;\n\nexport const AddButton = styled.button`\n  align-self: stretch;\n  appearance: none;\n  border: ${BORDER_WIDTH}px solid ${({ hex }) => createOffsetColor(hex)};\n  border-radius: ${BORDER_RADIUS}px;\n  color: ${({ hex }) => createOffsetColor(hex)};\n  cursor: pointer;\n  display: block;\n  font-family: sans-serif;\n  font-weight: bold;\n  font-size: 14px;\n  height: 100%;\n  justify-self: stretch;\n  text-transform: uppercase;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: box-shadow, background, opacity, transform, width, height;\n  width: 100%;\n  outline: 0;\n\n  ${({ isTargeted }) =>\n    isTargeted\n      ? css`\n          background: ${({ hex }) => createTargetColor(hex)};\n          /* transform: scale(${SCALE_600}); */\n          transform: translate(-${SPACE_300}px, -${SPACE_300}px);\n          width: calc(100% + ${SPACE_400}px);\n          height: calc(100% + ${SPACE_400}px);\n        `\n      : css`\n          background: ${({ hex }) => hex};\n          /* transform: scale(${SCALE_300}); */\n        `};\n\n  &:focus,\n  &:hover {\n    box-shadow: ${({ hex }) => createFocusStateWithShadow(hex)};\n  }\n\n  &:active {\n    background: ${({ hex }) => createActiveColor(hex)};\n  }\n`;\n\nconst Input = styled.input`\n  ${positionAbsolute}\n  appearance: none;\n  opacity: 0;\n`;\n\nexport const DeleteButton = styled(AddButton)`\n  height: ${SPACE_700}px;\n  position: absolute;\n  right: 0;\n  top: 0;\n  width: ${SPACE_700}px;\n\n  /** React CSSTransition animation property when the add <button /> is in NOT ACTIVE. */\n  &.deleteItem-enter,\n  &.deleteItem-exit {\n    opacity: 0;\n    transform: translate(${SPACE_500}px, -${SPACE_500}px) scale(${SCALE_300});\n  }\n\n  /** React CSSTransition animation property when the add <button /> is in IS ACTIVE. */\n  &.deleteItem-enter-active,\n  &.deleteItem-enter-done {\n    opacity: 1;\n    transform: translate(${SPACE_500}px, -${SPACE_500}px) scale(${SCALE_500});\n  }\n`;\n\nexport const Swatches = SwatchList;\n\nexport const UserSwatch = memo(\n  ({\n    swatchId,\n    hex,\n    handleChange,\n    handleDragStart,\n    handleDragOver,\n    handleDragExit,\n    handleDragEnd,\n    handleDrop,\n    isUserDragging,\n    isDeleting,\n    handleDelete,\n    hasCapacityToDelete,\n    createReorderTransform,\n    shouldSwatchPronounce,\n    shouldSwatchRegress\n  }) => {\n    const [isDragged, setIsDragged] = useState(false);\n    const [isAboutToDrag, setIsAboutToDrag] = useState(false);\n\n    /**\n     * We are debouncing the color input change to our `swatch` global state.\n     * Debouncing causes the swatch hex to hang on the current value until the\n     * callback finally updates. This \"hanging\" makes the native color `<input />`\n     * constantly revert back to the swatch hex rather than the users current\n     * selection.\n     *\n     * In that regard, we need to keep a local reference to what the user has\n     * selected as their \"next\" hex choice so that the UI responds with a snappy\n     * experience.\n     */\n    const [inputValue, setInputValue] = useState(hex);\n    const debouncedInputHandler = debounce(value => handleChange(swatchId, value), 100);\n\n    const swatchRef = useRef(null);\n\n    return (\n      <DragHitBox\n        {...{\n          isDragged,\n          isUserDragging,\n          hex,\n          shouldSwatchPronounce,\n          shouldSwatchRegress,\n          isDeleting,\n          hasCapacityToDelete\n        }}\n        draggable={!isDeleting}\n        ref={swatchRef}\n        onDragStart={event => {\n          setIsAboutToDrag(false);\n          /*\n           * Even though we are setting the drag n drop state through React Firefox\n           * will not initialise a DnD scenario without setting the `dataTransfer`.\n           */\n          event.dataTransfer.setData(\"text/plain\", \"banana\");\n\n          /**\n           * Set the drag image that will \"stick\" to the users mouse position during\n           * the entire drag sequence.\n           */\n          const offset = SWATCH_WIDTH / 2;\n          event.dataTransfer.setDragImage(swatchRef.current, offset, offset);\n\n          setIsDragged(true);\n          handleDragStart(swatchId);\n        }}\n        onDragEnd={() => {\n          setIsDragged(false);\n          handleDragEnd();\n        }}\n        onDragOver={event => {\n          handleDragOver(swatchId);\n          /*\n           * MDN suggests applying `preventDefault` on specific DnD event hooks.\n           * @see https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Handle_the_drop_effect\n           */\n          event.preventDefault();\n        }}\n        onDragLeave={handleDragExit}\n        onDrop={event => {\n          setIsDragged(false);\n          handleDrop(swatchId);\n          /*\n           * MDN suggests applying `preventDefault` on specific DnD event hooks.\n           * @see https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Handle_the_drop_effect\n           */\n          event.preventDefault();\n        }}\n        onMouseDown={isDeleting ? undefined : () => setIsAboutToDrag(true)}\n        onMouseUp={isDeleting ? undefined : () => setIsAboutToDrag(false)}\n      >\n        <ReorderTransformation\n          {...{ isDragged, isUserDragging }}\n          reorderTransform={createReorderTransform(swatchRef.current)}\n        >\n          <UserItem\n            {...{ hex, isDragged, isUserDragging, isAboutToDrag, shouldSwatchRegress, isDeleting }}\n          >\n            <CSSTransition\n              unmountOnExit\n              in={isDeleting && hasCapacityToDelete}\n              timeout={SPEED_700}\n              classNames=\"deleteItem\"\n            >\n              <DeleteButton hex={GRAY_300} onClick={() => handleDelete(swatchId)}>\n                <FontAwesomeIcon icon={faPlus} size=\"1x\" />\n              </DeleteButton>\n            </CSSTransition>\n          </UserItem>\n          {!isDeleting && (\n            <Input\n              type=\"color\"\n              value={inputValue}\n              onChange={event => {\n                const { value } = event.target;\n                setInputValue(value);\n                debouncedInputHandler(value);\n              }}\n            />\n          )}\n        </ReorderTransformation>\n      </DragHitBox>\n    );\n  }\n);\n\nexport const AppendSwatch = memo(({ dragHex, handleClick, handleDrop }) => {\n  const [isTargeted, setIsTargeted] = useState(false);\n\n  return (\n    <AddItem>\n      <AddButton\n        {...{ isTargeted }}\n        hex={isTargeted && dragHex ? dragHex : GRAY_300}\n        onClick={handleClick}\n        onDragOver={event => {\n          /*\n           * An `onDragOver` event MUST be present in order for a `onDrop` to\n           * trigger!\n           */\n          setIsTargeted(true);\n          event.preventDefault();\n        }}\n        onDragLeave={() => setIsTargeted(false)}\n        onMouseEnter={() => setIsTargeted(true)}\n        onMouseLeave={() => setIsTargeted(false)}\n        onDrop={event => {\n          handleDrop();\n          setIsTargeted(false);\n          /*\n           * MDN suggests applying `preventDefault` on specific DnD event hooks.\n           * @see https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Handle_the_drop_effect\n           */\n          event.preventDefault();\n        }}\n      >\n        <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n      </AddButton>\n    </AddItem>\n  );\n});\n","import React, { memo, useEffect, useRef, useState } from \"react\";\nimport { CSSTransition } from \"react-transition-group\";\nimport styled, { css } from \"styled-components\";\nimport tinyColor from \"tinycolor2\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faPlus, faCheck, faTimes } from \"@fortawesome/free-solid-svg-icons\";\nimport {\n  faCheckCircle,\n  faCalendarAlt,\n  faCommentDots,\n  faStar,\n  faTrashAlt\n} from \"@fortawesome/free-regular-svg-icons\";\nimport {\n  BLACK,\n  GRAY_300,\n  GRAY_900,\n  COMP_WIDTH,\n  COMP_HEIGHT,\n  BORDER_RADIUS,\n  BORDER_WIDTH,\n  SCALE_200,\n  SCALE_300,\n  SCALE_500,\n  SCALE_600,\n  SPACE_400,\n  SPACE_600,\n  SPACE_800,\n  SPEED_500,\n  SPEED_700,\n  LUMINANCE_SHADOW_500,\n  createSwatch,\n  checkHasLowLuminance,\n  resetList,\n  positionAbsolute,\n  deleteAnimation\n} from \"./utils\";\nimport { AppendSwatch, AddItem, AddButton, DeleteButton } from \"./Swatch\";\n\nconst CompList = styled.ul`\n  ${resetList}\n  display: grid;\n  grid-gap: ${SPACE_600}px;\n  grid-template-columns: repeat(auto-fit, minmax(${COMP_WIDTH}px, auto));\n  /* grid-template-rows: repeat(auto-fill, minmax(${COMP_HEIGHT}px, auto)); */\n\n  > * {\n    min-height: ${COMP_HEIGHT}px;\n    min-width: ${COMP_WIDTH}px;\n  }\n`;\n\nconst IconList = styled.ul`\n  ${resetList}\n\n  display: grid;\n  grid-template-columns: repeat(auto-fit, 1rem);\n  grid-gap: ${SPACE_600}px;\n`;\n\nconst DividerList = styled.ul`\n  ${resetList}\n  display: grid;\n  grid-gap: ${SPACE_600}px;\n  grid-template-columns: 1fr;\n`;\n\nconst ResultList = styled.ul`\n  ${resetList}\n  display: flex;\n  border-radius: 0 0 ${BORDER_RADIUS}px ${BORDER_RADIUS}px;\n  background: ${GRAY_300};\n  color: ${GRAY_900};\n  justify-content: space-between;\n  padding: ${SPACE_600}px;\n  font-family: monospace;\n  font-size: 24px;\n  font-weight: bold;\n  align-items: center;\n\n  > * {\n    display: block;\n  }\n`;\n\nconst Character = styled.span`\n  opacity: ${({ children }) => (children === \"A\" ? 1 : 0.25)};\n`;\n\nconst UserItem = styled.div`\n  height: 100%;\n  width: 100%;\n  position: relative;\n  transition-property: opacity, transform;\n  transition-duration: ${SPEED_500}ms;\n  transform: scale(SCALE_500);\n\n  ${({ isUserDragging }) =>\n    isUserDragging &&\n    css`\n      opacity: 0.5;\n      pointer-events: none;\n      /* transform: scale(${SCALE_300}); */\n    `}\n\n  ${({ isDeleting, hasCapacityToDelete }) =>\n    isDeleting && hasCapacityToDelete && deleteAnimation(0.5)}\n`;\n\nconst Examples = styled.div`\n  /**\n   * Targeting the \"Base\" and \"Content\" hex values via CSS variables as the\n   * performance is more optimal than re-rendering a baked in value on every change.\n   *\n   * It also fixes an issue when referencing currentColor within a linear\n   * gradient (inconsistent in browsers).\n   */\n  --baseHex: ${({ baseHex }) => baseHex};\n  --contentHex: ${({ contentHex }) => contentHex};\n\n  border-radius: ${BORDER_RADIUS}px ${BORDER_RADIUS}px 0 0;\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-template-rows: auto;\n  grid-gap: ${SPACE_600}px;\n  background: var(--baseHex);\n  color: var(--contentHex);\n  padding: ${SPACE_600}px;\n  position: relative;\n  font-family: sans-serif;\n  transition: background ${SPEED_700}ms;\n\n  > * {\n    display: block;\n  }\n\n  ${({ baseHex }) => {\n    /**\n     * Correspond with the <Swatch /> luminance aesthetic to differentiate VERY\n     * \"light\" colors from the application background.\n     */\n    if (checkHasLowLuminance(baseHex)) {\n      return css`\n        &:after {\n          ${positionAbsolute}\n          border-radius: ${BORDER_RADIUS}px ${BORDER_RADIUS}px 0 0;\n          box-shadow: ${LUMINANCE_SHADOW_500};\n          content: \"\";\n          display: block;\n        }\n      `;\n    }\n  }}\n`;\n\nconst SmallText = styled.span`\n  /**\n   * Force font size to be pixels (px) rather than something scaleable like rems\n   * so that we can force the \"worst case scenario\" when creating our color\n   * compositions.\n   */\n  display: block;\n  font-size: ${({ isBold }) => `${isBold ? 14 : 16}px`};\n  font-weight: ${({ isBold }) => (isBold ? \"bold\" : \"initial\")};\n`;\n\nconst Divider = styled.div`\n  border-radius: ${BORDER_RADIUS}px;\n  height: ${({ height }) => `${height}px`};\n  background-image: linear-gradient(to right, var(--contentHex), transparent);\n`;\n\nexport const Compositions = CompList;\n\nconst createContrastPercentage = (baseHex, contentHex) => {\n  const ratio = tinyColor.readability(baseHex, contentHex);\n  const percentage = (ratio / 21) * 100;\n\n  return Math.round(percentage);\n};\n\nconst createAccessibilityComparison = (baseHex, contentHex) => level =>\n  tinyColor.isReadable(baseHex, contentHex, { level, size: \"small\" });\n\nconst findAccessibilityLevel = (baseHex, contentHex) => {\n  const comparison = createAccessibilityComparison(baseHex, contentHex);\n\n  switch (true) {\n    case comparison(\"AAA\"):\n      return \"AAA\";\n    case comparison(\"AA\"):\n      return \"AA-\";\n    default:\n      return \"---\";\n  }\n};\n\nconst Icons = () => (\n  <div>\n    <IconList>\n      {[faCheckCircle, faCalendarAlt, faCommentDots, faStar, faTrashAlt].map((icon, index) => (\n        <li key={index}>\n          <FontAwesomeIcon {...{ icon }} />\n        </li>\n      ))}\n    </IconList>\n  </div>\n);\n\nconst Dividers = () => (\n  <div>\n    <DividerList>\n      {[1, 2, 4].map(height => (\n        <li key={height}>\n          <Divider {...{ height }} />\n        </li>\n      ))}\n    </DividerList>\n  </div>\n);\n\nconst Level = ({ children: level }) => {\n  const characters = level\n    .split(\"\")\n    .map((char, index) => <Character key={index}>{char}</Character>);\n\n  return <span>{characters}</span>;\n};\n\nconst DropAreas = styled.div`\n  ${positionAbsolute}\n  align-items: stretch;\n  display: grid;\n  grid-gap: ${SPACE_600}px;\n  justify-items: stretch;\n  padding: ${SPACE_600}px;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n\n  ${({ isUserDragging }) =>\n    !isUserDragging &&\n    css`\n      opacity: 0;\n      pointer-events: none;\n      transform: scale(${SCALE_600});\n    `}\n`;\n\nconst ResultIcon = styled(FontAwesomeIcon)`\n  transform: scale(${SCALE_600});\n`;\n\nconst Results = ({ baseHex, contentHex }) => {\n  const level = findAccessibilityLevel(baseHex, contentHex);\n  const icon = level.includes(\"AA\") ? faCheck : faTimes;\n  const percentage = createContrastPercentage(baseHex, contentHex);\n\n  return (\n    <div>\n      <ResultList>\n        <ResultIcon {...{ icon }} size=\"1x\" />\n        <Level>{level}</Level>\n        <span>{percentage}%</span>\n      </ResultList>\n    </div>\n  );\n};\n\nconst ItemWrapper = styled.li`\n  position: relative;\n  transition-duration: ${SPEED_500}ms;\n  transition-property: opacity, transform;\n\n  /** React CSSTransition animation property when an item is in its DORMANT state. */\n  &.composition-enter,\n  &.composition-exit,\n  &.composition-exit-active {\n    opacity: 0;\n    transform: scale(${SCALE_200});\n  }\n\n  /** React CSSTransition animation property when an item is in its ACTIVE state. */\n  &.composition-enter-active,\n  &.composition-enter-done {\n    opacity: 1;\n    transform: scale(${SCALE_500});\n  }\n`;\n\nconst AddCompositionButton = styled(AddButton)`\n  ${({ isActive }) =>\n    isActive\n      ? css`\n          opacity: 1;\n        `\n      : css`\n          opacity: 0;\n          pointer-events: none;\n        `}\n`;\n\nconst AddSlotButton = styled(AddButton)`\n  /**\n   * Hack for Safari, which does not confirm to positioning grid elements when\n   * the wrapper element has an opacity of 0. In that regard we staticky set\n   * the height of the slot 😩\n   */\n  min-height: 115px;\n`;\n\nexport const UserComposition = memo(\n  ({\n    compId,\n    baseId,\n    contentId,\n    dragStartId,\n    baseHex,\n    contentHex,\n    dragHex,\n    isUserDragging,\n    isDeleting,\n    hasCapacityToDelete,\n    handleDelete,\n    handleDrop,\n    setActiveCompositionId,\n    removeActiveCompositionId\n  }) => {\n    const [isContentTargeted, setIsContentTargeted] = useState(false);\n    const [isBaseTargeted, setIsBaseTargeted] = useState(false);\n\n    return (\n      <ItemWrapper>\n        <UserItem\n          {...{ isUserDragging, isDeleting, hasCapacityToDelete }}\n          onMouseEnter={isDeleting ? undefined : () => setActiveCompositionId(compId)}\n          onMouseLeave={isDeleting ? undefined : removeActiveCompositionId}\n        >\n          <Examples {...{ baseHex, contentHex }}>\n            <SmallText>The quick brown fox,</SmallText>\n            <SmallText isBold>jumps over the lazy dog.</SmallText>\n            <Icons />\n            <Dividers />\n          </Examples>\n          <Results {...{ baseHex, contentHex }} />\n          <CSSTransition\n            unmountOnExit\n            in={isDeleting && hasCapacityToDelete}\n            timeout={SPEED_700}\n            classNames=\"deleteItem\"\n          >\n            <DeleteButton hex={GRAY_300} onClick={() => handleDelete(compId)}>\n              <FontAwesomeIcon icon={faPlus} size=\"1x\" />\n            </DeleteButton>\n          </CSSTransition>\n        </UserItem>\n        <DropAreas {...{ isUserDragging }}>\n          <AddSlotButton\n            hex={isContentTargeted ? dragHex : contentHex}\n            isTargeted={isContentTargeted}\n            onDragOver={event => {\n              setIsContentTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsContentTargeted(false)}\n            onDrop={event => {\n              handleDrop(compId, { contentId: dragStartId, baseId });\n              setIsContentTargeted(false);\n              setIsBaseTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n          <AddSlotButton\n            hex={isBaseTargeted ? dragHex : baseHex}\n            isTargeted={isBaseTargeted}\n            onDragOver={event => {\n              setIsBaseTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsBaseTargeted(false)}\n            onDrop={event => {\n              handleDrop(compId, { contentId, baseId: dragStartId });\n              setIsContentTargeted(false);\n              setIsBaseTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n        </DropAreas>\n      </ItemWrapper>\n    );\n  }\n);\n\nexport const AppendComposition = memo(\n  ({ dragHex, dragStartId, handleClick, handleDrop, isUserDragging }) => {\n    const [isAddTargeted, setIsAddTargeted] = useState(false);\n    const [isContentTargeted, setIsContentTargeted] = useState(false);\n    const [isBaseTargeted, setIsBaseTargeted] = useState(false);\n\n    return (\n      <AddItem>\n        <DropAreas {...{ isUserDragging }}>\n          <AddSlotButton\n            hex={isContentTargeted ? dragHex : GRAY_300}\n            isTargeted={isContentTargeted}\n            onDragOver={event => {\n              setIsContentTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsContentTargeted(false)}\n            onDrop={event => {\n              handleDrop({ contentId: dragStartId });\n              setIsContentTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n          <AddSlotButton\n            hex={isBaseTargeted ? dragHex : GRAY_300}\n            isTargeted={isBaseTargeted}\n            onDragOver={event => {\n              setIsBaseTargeted(true);\n              event.preventDefault();\n            }}\n            onDragLeave={() => setIsBaseTargeted(false)}\n            onDrop={event => {\n              handleDrop({ baseId: dragStartId });\n              setIsContentTargeted(false);\n              setIsBaseTargeted(false);\n              event.preventDefault();\n            }}\n          >\n            <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n          </AddSlotButton>\n        </DropAreas>\n        <AddCompositionButton\n          hex={GRAY_300}\n          isActive={!isUserDragging}\n          isTargeted={isAddTargeted}\n          onClick={handleClick}\n          onMouseEnter={() => setIsAddTargeted(true)}\n          onMouseLeave={() => setIsAddTargeted(false)}\n        >\n          <FontAwesomeIcon icon={faPlus} size=\"2x\" />\n        </AddCompositionButton>\n      </AddItem>\n    );\n  }\n);\n","import React, { memo, useEffect, useRef, useState } from \"react\";\nimport styled, { css } from \"styled-components\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faTrashAlt, faTasks } from \"@fortawesome/free-solid-svg-icons\";\nimport { faGithubAlt } from \"@fortawesome/free-brands-svg-icons\";\nimport {\n  BLACK,\n  GRAY_300,\n  GRAY_900,\n  COMP_WIDTH,\n  COMP_HEIGHT,\n  BORDER_RADIUS,\n  BORDER_WIDTH,\n  SCALE_200,\n  SCALE_300,\n  SCALE_500,\n  SCALE_600,\n  SPACE_400,\n  SPACE_500,\n  SPACE_600,\n  SPACE_800,\n  SPEED_500,\n  SPEED_700,\n  LUMINANCE_SHADOW_500,\n  createSwatch,\n  checkHasLowLuminance,\n  resetList,\n  positionAbsolute\n} from \"./utils\";\nimport { AddButton } from \"./Swatch\";\n\nconst Button = styled(AddButton)`\n  display: inline-flex;\n  align-items: center;\n  width: auto;\n  padding: 0 ${SPACE_500}px;\n  text-decoration: none;\n\n  > *:nth-child(1n + 2) {\n    margin-left: ${SPACE_400}px;\n  }\n`;\n\nconst ButtonHeader = styled.header`\n  height: ${SPACE_800}px;\n  display: flex;\n  justify-content: space-between;\n`;\n\nexport const Header = memo(({ isDeleting, handleDeleteToggle }) => (\n  <ButtonHeader>\n    <Button hex={GRAY_300} as=\"a\" href=\"https://github.com/devonChurch/avocado\">\n      <FontAwesomeIcon icon={faGithubAlt} size=\"1x\" />\n      <span>Github</span>\n    </Button>\n    <Button hex={GRAY_300} onClick={handleDeleteToggle}>\n      <FontAwesomeIcon icon={isDeleting ? faTasks : faTrashAlt} size=\"1x\" />\n      <span>{isDeleting ? \"Edit\" : \"Delete\"}</span>\n    </Button>\n  </ButtonHeader>\n));\n","import \"normalize.css\";\nimport \"drag-drop-touch\";\nimport React, { useCallback, useMemo, useRef, useState, useEffect } from \"react\";\nimport { TransitionGroup, CSSTransition } from \"react-transition-group\";\nimport nanoid from \"nanoid\";\nimport throttle from \"lodash.throttle\";\nimport { createGlobalStyle } from \"styled-components\";\nimport { Swatches, UserSwatch, AppendSwatch } from \"./Swatch\";\nimport { Compositions, UserComposition, AppendComposition } from \"./Composition\";\nimport { Header } from \"./Header\";\nimport {\n  SWATCH_WIDTH,\n  BLACK,\n  SPACE_600,\n  SPEED_500,\n  SPEED_700,\n  WHITE,\n  findColorComplementFromSwatches,\n  createSwatch,\n  convertStateToQuery,\n  convertStateFromQuery\n} from \"./utils\";\n\nconst GlobalStyle = createGlobalStyle`\n  html {\n    box-sizing: border-box;\n  }\n  \n  *, *:before, *:after {\n    box-sizing: inherit;\n  }\n\n  body {\n    padding: 50px;\n  }\n\n  #root {\n    display: grid;\n    grid-gap: ${SPACE_600}px;\n  }\n`;\n\nconst createSwatchKey = () => nanoid();\nconst createCompositionKey = createSwatchKey;\n\nconst createIndexComparison = idOne => ([idTwo]) => idOne === idTwo;\nconst findSwatchIndexFromId = (swatches, id) => swatches.findIndex(createIndexComparison(id));\nconst findCompositionIndexFromId = (compositions, id) =>\n  compositions.findIndex(createIndexComparison(id));\n\nconst createReorderTransform = (x = 0, y = 0) => `transform: translate(${x}%, ${y}%);`;\n\n/**\n * Returns a thunk that can calculate the CSS transformation that reorders swatches\n * that the user drags over based not he origin of the dragged swatch.\n */\nconst calculateReorderTransform = (swatches, dragStartId, dragOverId, swatchIndex) => {\n  /** Only calculate if we have the relevant information. */\n  const isInDragOverState = dragStartId && dragOverId && dragStartId !== dragOverId;\n  if (!isInDragOverState) return createReorderTransform;\n\n  /** Only calculate if the current swatch is not the originating dragging swatch. */\n  const dragStartIndex = findSwatchIndexFromId(swatches, dragStartId);\n  const dragOverIndex = findSwatchIndexFromId(swatches, dragOverId);\n  const shouldReorder = dragStartIndex !== swatchIndex;\n  if (!shouldReorder) return createReorderTransform;\n\n  /**\n   * Only calculate is the current swatch falls between the originating dragged\n   * swatch and the dragged over swatch. All outside swatches remain static.\n   */\n  const isBeforeDragSwatches = swatchIndex >= dragStartIndex || swatchIndex >= dragOverIndex;\n  const isAfterDragSwatches = swatchIndex <= dragStartIndex || swatchIndex <= dragOverIndex;\n  const isBetweenDragSwatches = isBeforeDragSwatches && isAfterDragSwatches;\n  if (!isBetweenDragSwatches) return createReorderTransform;\n\n  /**\n   * Based on the direction (\"left\" or \"right\") that the user is dragging we\n   * reorder the swatches that fall between the dragging indexes to fill the gap\n   * left from the originating dragged swatch.\n   */\n  return function positionReorderTransform(prevNode) {\n    const isDraggedRight = dragStartIndex > swatchIndex;\n    const siblingTarget = isDraggedRight ? \"nextElementSibling\" : \"previousElementSibling\";\n    const nextNode = prevNode[siblingTarget];\n    const { offsetTop: prevY, offsetLeft: prevX } = prevNode;\n    const { offsetTop: nextY, offsetLeft: nextX } = nextNode;\n    const dragX = ((nextX - prevX) / SWATCH_WIDTH) * 100;\n    const dragY = ((nextY - prevY) / SWATCH_WIDTH) * 100;\n\n    return createReorderTransform(dragX, dragY);\n  };\n};\n\nconst useThrottledState = (initialState, delay) => {\n  const [isPrepped, setIsPrepped] = useState(false);\n  const [state, setState] = useState(initialState);\n  const throttled = useRef();\n\n  useEffect(() => {\n    const handleUpdate = newState => setState(newState);\n    throttled.current = throttle(handleUpdate, delay, { trailing: false });\n\n    // Once the throttler has been setup we toggle a flag to ensure that we return\n    // the throttled state \"updater\"\n    if (!isPrepped) {\n      setIsPrepped(true);\n    }\n\n    // Destroy persistent throttle reference on unmount.\n    return () => throttled.current.cancel();\n\n    // Force the effect to ONLY run on init so as NOT to recreate the thriller\n    // setup (which would be super bad).\n  }, []);\n\n  return [\n    state,\n    // If we have NOT prepped the throttler yet then just send back the \"immediate\"\n    // setState reference.\n    isPrepped ? throttled.current : setState\n  ];\n};\n\nconst App = () => {\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** SWATCHES:   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n\n  // Se swap out the \"vanilla\" useState hook for a custom implementation that\n  // throttles the update of the \"swatches\" references. The swatch state is the\n  // catalyst for performant heavy re-renders (think hundreds of hex updates as\n  // you drag the native color slider). In that regard, we throttle the amount\n  // the swatches state can be updated.\n  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n  // const [swatches, setSwatches] = useState([]);\n  const [swatches, setSwatches] = useThrottledState(new Map([]), 1000);\n\n  const [dragStartId, setDragStartId] = useState(null);\n  const [dragOverId, setDragOverId] = useState(null);\n  const isUserDragging = !!dragStartId;\n  const dragHex = isUserDragging && swatches.get(dragStartId);\n\n  const removeDragStartId = () => setDragStartId(null);\n  const removeDragOverId = useCallback(() => setDragOverId(null), []);\n  const removeDragIds = useCallback(() => {\n    removeDragStartId(null);\n    removeDragOverId(null);\n  }, [removeDragOverId]);\n\n  const appendSwatch = hex => setSwatches(new Map([...swatches, [createSwatchKey(), hex]]));\n\n  const appendLastListedSwatch = () => {\n    const [, lastHex] = [...swatches].pop() || [];\n    appendSwatch(lastHex || BLACK);\n  };\n\n  const appendDraggedSwatch = () => {\n    appendSwatch(dragHex);\n    removeDragIds();\n  };\n\n  const updateUserSwatch = useCallback(\n    (id, hex) => setSwatches(new Map([...swatches, [id, hex]])),\n    [swatches]\n  );\n\n  const moveSwatchToNewLocation = useCallback(\n    dropId => {\n      if (dragStartId === dropId) return;\n\n      const prevSwatches = [...swatches];\n      const dropIndex = findSwatchIndexFromId(prevSwatches, dropId);\n      const dragStartIndex = findSwatchIndexFromId(prevSwatches, dragStartId);\n      const shoudPrepend = dropIndex < dragStartIndex;\n      const dropSwatch = [dragStartId, swatches.get(dragStartId)];\n      const nextSwatches = new Map(\n        prevSwatches.reduce((acc, [id, hex]) => {\n          switch (true) {\n            case id === dragStartId:\n              return acc; // Remove the swatch from its orignal location.\n            case id === dropId:\n              return shoudPrepend\n                ? [...acc, dropSwatch, [id, hex]]\n                : [...acc, [id, hex], dropSwatch];\n            default:\n              return [...acc, [id, hex]];\n          }\n        }, [])\n      );\n      setSwatches(nextSwatches);\n      removeDragIds();\n    },\n    [swatches, dragStartId, removeDragIds]\n  );\n\n  const createReorderTransformHandler = (...args) =>\n    calculateReorderTransform([...swatches], ...args);\n\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** COMPOSITIONS:  ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n  const [compositions, setCompositions] = useState([]);\n\n  const [activeCompositionId, setActiveCompositionId] = useState(null);\n  const removeActiveCompositionId = () => setActiveCompositionId(null);\n\n  const setSwatchAppearanceAgainstCompositionTarget = swatchId => {\n    if (!activeCompositionId) return;\n    const composition = compositions.get(activeCompositionId);\n    const hasBase = composition.baseId === swatchId;\n    const hasContent = composition.contentId === swatchId;\n    const shouldSwatchPronounce = hasBase || hasContent;\n    const shouldSwatchRegress = !shouldSwatchPronounce && activeCompositionId;\n\n    return { shouldSwatchPronounce, shouldSwatchRegress };\n  };\n\n  const appendComposition = ({ baseId, contentId } = {}) => {\n    const compositionIds = {\n      baseId: baseId || findColorComplementFromSwatches(contentId, swatches),\n      contentId: contentId || findColorComplementFromSwatches(baseId, swatches)\n    };\n    setCompositions(new Map([...compositions, [createCompositionKey(), compositionIds]]));\n  };\n\n  const appendLastListedComposition = () => {\n    const [, compositionIds] = [...compositions].pop() || [];\n    appendComposition(compositionIds);\n  };\n\n  const appendCompositionFromDraggedSwatch = compositionIds => {\n    appendComposition(compositionIds);\n    removeDragIds();\n  };\n\n  const updateComposition = useCallback(\n    (compId, composition) => {\n      const prevComps = [...compositions];\n      const compIndex = findCompositionIndexFromId(prevComps, compId);\n      const nextComps = [\n        ...prevComps.slice(0, compIndex),\n        [compId, composition],\n        ...prevComps.slice(compIndex + 1)\n      ];\n      setCompositions(new Map(nextComps));\n    },\n    [compositions]\n  );\n\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** QUERY STRING:  ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n\n  useEffect(() => {\n    const { swatches, compositions } = convertStateFromQuery(window.location.search);\n\n    setSwatches(swatches);\n    setCompositions(compositions);\n  }, []);\n\n  useEffect(() => {\n    const search = convertStateToQuery(swatches, compositions);\n    const { protocol, host, pathname } = window.location;\n    const url = `${protocol}//${host}${pathname}${search}`;\n\n    window.history.replaceState({}, \"\", url);\n  }, [swatches, compositions]);\n\n  /** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** DELETE:  ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **\n   ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **/\n\n  const [isDeleting, setIsDeleting] = useState(false);\n  const handleDeleteToggle = () => setIsDeleting(!isDeleting);\n\n  const deleteSwatch = useCallback(\n    swatchId => {\n      const prevSwatches = [...swatches];\n      const swatchIndex = findSwatchIndexFromId(prevSwatches, swatchId);\n      const nextSwatches = [\n        ...prevSwatches.slice(0, swatchIndex),\n        ...prevSwatches.slice(swatchIndex + 1)\n      ];\n      setSwatches(new Map(nextSwatches));\n    },\n    [swatches]\n  );\n\n  const deleteComposition = useCallback(\n    compId => {\n      const prevComps = [...compositions];\n      const compIndex = findCompositionIndexFromId(prevComps, compId);\n      const nextComps = [...prevComps.slice(0, compIndex), ...prevComps.slice(compIndex + 1)];\n      setCompositions(new Map(nextComps));\n    },\n    [compositions]\n  );\n\n  const hasEnoughSwatchesToDelete = swatches.size > 2;\n  const hasEnoughCompositionsToDelete = compositions.size > 1;\n\n  const checkIsSwatchInAnyComposition = (() => {\n    const activeSwatchIds = [...compositions.values()].reduce(\n      (acc, { baseId, contentId }) => [...acc, baseId, contentId],\n      []\n    );\n\n    return swatchId => activeSwatchIds.includes(swatchId);\n  })();\n\n  return (\n    <>\n      <GlobalStyle />\n      <Header {...{ isDeleting, handleDeleteToggle }} />\n      <TransitionGroup component={Swatches}>\n        {[...swatches].map(([swatchId, hex], swatchIndex) => (\n          <CSSTransition key={swatchId} timeout={SPEED_700} classNames=\"swatch\">\n            <UserSwatch\n              key={swatchId}\n              {...{\n                swatchId,\n                hex,\n                isUserDragging,\n                isDeleting,\n                ...setSwatchAppearanceAgainstCompositionTarget(swatchId)\n              }}\n              hasCapacityToDelete={\n                hasEnoughSwatchesToDelete && !checkIsSwatchInAnyComposition(swatchId)\n              }\n              handleChange={updateUserSwatch}\n              handleDragStart={setDragStartId}\n              handleDragOver={setDragOverId}\n              handleDragExit={removeDragOverId}\n              handleDragEnd={removeDragIds}\n              handleDrop={moveSwatchToNewLocation}\n              handleDelete={deleteSwatch}\n              createReorderTransform={createReorderTransformHandler(\n                dragStartId,\n                dragOverId,\n                swatchIndex\n              )}\n            />\n          </CSSTransition>\n        ))}\n        <>\n          {/**\n           * Use a <Fragment /> to protect the \"append\" <CSSTransitions /> from\n           * absorbing the parent <TransitionGroup />.\n           */\n          isDeleting ? (\n            /**\n             * Add in a placeholder so that the missing space does NOT cause\n             * aggressive reflow.\n             */\n            <div />\n          ) : (\n            <CSSTransition unmountOnExit in={!isDeleting} timeout={SPEED_700} classNames=\"addItem\">\n              <AppendSwatch\n                {...{ dragHex }}\n                handleClick={appendLastListedSwatch}\n                handleDrop={appendDraggedSwatch}\n              />\n            </CSSTransition>\n          )}\n        </>\n      </TransitionGroup>\n      <TransitionGroup component={Compositions}>\n        {[...compositions].map(([compId, { baseId, contentId }]) => (\n          <CSSTransition key={compId} timeout={SPEED_700} classNames=\"composition\">\n            <UserComposition\n              key={compId}\n              {...{\n                compId,\n                baseId,\n                contentId,\n                dragStartId,\n                dragHex,\n                isUserDragging,\n                isDeleting,\n                setActiveCompositionId,\n                removeActiveCompositionId\n              }}\n              hasCapacityToDelete={hasEnoughCompositionsToDelete}\n              baseHex={swatches.get(baseId)}\n              contentHex={swatches.get(contentId)}\n              handleDrop={updateComposition}\n              handleDelete={deleteComposition}\n            />\n          </CSSTransition>\n        ))}\n        <>\n          {isDeleting ? (\n            <div />\n          ) : (\n            <CSSTransition unmountOnExit in={!isDeleting} timeout={SPEED_700} classNames=\"addItem\">\n              <AppendComposition\n                {...{ dragStartId, dragHex, isUserDragging }}\n                handleClick={appendLastListedComposition}\n                handleDrop={appendCompositionFromDraggedSwatch}\n              />\n            </CSSTransition>\n          )}\n        </>\n      </TransitionGroup>\n    </>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n// import * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}